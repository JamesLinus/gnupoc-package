diff --git a/abld b/abld
new file mode 100644
index 0000000..e273bf3
--- /dev/null
+++ b/abld
@@ -0,0 +1,19 @@
+#!/bin/sh
+#
+# abld - shell frontend for abld.pl, part of GnuPoc project
+#
+# (c) 2001-2002 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+#
+# note: small tweak to get symlinks working. 'pwd' returns the path as seen
+#       by `pwd` - but 'cwd' returns the real path, as used by the tool chain.
+#       this also works if no symlinks are used:
+#
+#       perl -S abld.pl `pwd`/ "$@"
+    
+perl -S abld.pl `perl -e 'use Cwd; my $cwd = cwd(); print "$cwd/"'` "$@"
diff --git a/abld.pl b/abld.pl
index eb70e82..a4d1ed1 100644
--- a/abld.pl
+++ b/abld.pl
@@ -1,18 +1,19 @@
+#!/usr/bin/perl -w
+#
 # ABLD.PL
 #
-# Copyright (c) 1997-1999 Symbian Ltd.  All rights reserved.
+# Copyright (c) 1997-2001 Symbian Ltd.  All rights reserved.
 #
 
 # find the directory containing ABLD.PL
 my $PerlLibPath;
 BEGIN {
 	require 5.003_07;
-	foreach (split ';', $ENV{Path}) {
-		s-/-\\-go;	# for those working with UNIX shells
+	foreach (split ':', $ENV{PATH}) {
 		s-^$-.-o;	# convert empty string to .
-		s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-		if (-e $_.'ABLD.PL') {
-			$PerlLibPath=uc $_;
+		s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a slash
+		if (-e $_.'abld.pl') {
+			$PerlLibPath=$_;
 			last;
 		}
 	}
@@ -24,7 +25,7 @@ use Getopt::Long;
 
 # allow loading of libraries from the ABLD.PL directory
 use lib $PerlLibPath;
-use E32env;
+use e32env;
 
 # command data structure
 my %Commands=(
@@ -65,7 +66,7 @@ my %Commands=(
 	},
 	FREEZE=>{
 		program=>1,
-		function=>'Freezes exported functions in a .DEF file',
+		function=>'Freezes exported functions in a .def file',
 	},
 	HELP=>{
 		noplatform=>1,
@@ -74,7 +75,7 @@ my %Commands=(
 	},
 	LIBRARY=>{
 		program=>1,
-		function=>'Creates import libraries from the frozen .DEF files',
+		function=>'Creates import libraries from the frozen .def files',
 	},
 	LISTING=>{
 		build=>1,
@@ -132,10 +133,10 @@ my $BldInfDir;
 my $PrjBldDir;
 BEGIN {
 	$BldInfDir=shift @ARGV;
-	$PrjBldDir=$E32env::Data{BldPath};
-	$PrjBldDir=~s-^(.*)\\-$1-o;
+	$PrjBldDir=$e32env::Data{BldPath};
+	$PrjBldDir=~s-^(.*)\/-$1-o;
 	$PrjBldDir.=$BldInfDir;
-	$PrjBldDir=~m-(.*)\\-o; # remove backslash because some old versions of perl can't cope
+	$PrjBldDir=~m-(.*)\/-o; # remove backslash because some old versions of perl can't cope
 	unless (-d $1) {
 		die "ABLD ERROR: Project Bldmake directory \"$PrjBldDir\" does not exist\n";
 	}
@@ -143,12 +144,12 @@ BEGIN {
 
 # check the platform module exists and then load it
 BEGIN {
-	unless (-e "${PrjBldDir}Platform.pm") {
-		die "ABLD ERROR: \"${PrjBldDir}Platform.pm\" not yet created\n";
+	unless (-e "${PrjBldDir}platform.pm") {
+		die "ABLD ERROR: \"${PrjBldDir}platform.pm\" not yet created\n";
 	}
 }
 use lib $PrjBldDir;
-use Platform;
+use platform;
 
 # change directory to the BLD.INF directory so that extension makefiles
 # can specify paths relative to that directory.
@@ -249,7 +250,7 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 		}
 		else {
 			COMPARAM1 : {
-				if (grep(/^$Plat$/, ('ALL', @Platform::Plats))) {
+				if (grep(/^$Plat$/i, ('ALL', @platform::Plats))) {
 					last COMPARAM1;
 				}
 #				check whether the platform might in fact be a build, and
@@ -264,8 +265,8 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 #				check whether the platform might in fact be a program, and
 #				set the platform, build and program accordingly if it is
 				if ($CommandHash{program}) {
-					if  (((not $Test) and grep /^$Plat$/, @{$Platform::Programs{ALL}})
-							or ($Test and grep /^$Plat$/, @{$Platform::TestPrograms{ALL}})) {
+					if  (((not $Test) and grep /^$Plat$/, @{$platform::Programs{ALL}})
+							or ($Test and grep /^$Plat$/, @{$platform::TestPrograms{ALL}})) {
 						$Program=$Plat;
 						$Plat='ALL';
 						$Bld='ALL';
@@ -309,8 +310,8 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 #					check whether the build might in fact be a program, and
 #					set the build and program if it is
 					if ($CommandHash{program}) {
-						if  (((not $Test) and grep /^$Bld$/, @{$Platform::Programs{$Plat}})
-								or ($Test and grep /^$Bld$/, @{$Platform::TestPrograms{$Plat}})) {
+						if  (((not $Test) and grep /^$Bld$/, @{$platform::Programs{$Plat}})
+								or ($Test and grep /^$Bld$/, @{$platform::TestPrograms{$Plat}})) {
 							$Program=$Bld;
 							$Bld='ALL';
 							last COMPARAM2;
@@ -340,13 +341,13 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 #	get the program parameter for those commands which require it
 	if ($CommandHash{program}) {
 		unless ($Program) {
-			unless ($Program=uc shift @ARGV) {
+			unless ($Program=shift @ARGV) {
 				$Program=''; #default - means ALL
 			}
 			else {
 #				check that the program is supported
-				unless (((not $Test) and grep /^$Program$/, @{$Platform::Programs{$Plat}})
-						or ($Test and grep /^$Program$/, @{$Platform::TestPrograms{$Plat}})) {
+				unless (((not $Test) and grep /^$Program$/, @{$platform::Programs{$Plat}})
+						or ($Test and grep /^$Program$/, @{$platform::TestPrograms{$Plat}})) {
 					my $Error="This project does not support $Test program \"$Program\"";
 					if ($Plat eq 'ALL') {
 						$Error.=" for any platform\n";
@@ -379,7 +380,7 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 	my @Plats;
 	unless ($CommandHash{noplatform}) {
 		if ($Plat eq 'ALL') {
-			@Plats=@Platform::RealPlats;
+			@Plats=@platform::RealPlats;
 #			hack for WINSCW - remove WINSCW from the "ALL" list
 			@Plats=grep !/CW$/o, @Plats;
 			if ($CommandHash{build}) {
@@ -398,8 +399,9 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 		}
 
 		foreach $Plat (@Plats) {
-			unless (-e "$PrjBldDir$Plat$Test.make") {
-				die "ABLD ERROR: \"$PrjBldDir$Plat$Test.make\" not yet created\n";
+		  my $lcplat = lc $Plat;
+			unless (-e "$PrjBldDir$lcplat$Test.make") {
+				die "ABLD ERROR: \"$PrjBldDir$lcplat$Test.make\" not yet created\n";
 			}
 		}
 		undef $Plat;
@@ -436,19 +438,20 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 		$VerboseMacro='';
 	}
 
-#	set up a list of nmake calls
+#	set up a list of make calls
 	my @Calls;
 
 #	handle the exports related calls first
 	if (($Command)=grep /^(.*EXPORT)$/o, @Commands) { # EXPORT, CLEANEXPORT
-		unless (-e "${PrjBldDir}EXPORT$Test.make") {
-			die "ABLD ERROR: \"${PrjBldDir}EXPORT$Test.make\" not yet created\n";
+		unless (-e "${PrjBldDir}export$Test.make") {
+			die "ABLD ERROR: \"${PrjBldDir}export$Test.make\" not yet created\n";
 		}
 		unless ($Options{what} or $Options{check}) {
-			push @Calls, "nmake -nologo$KeepgoingFlag -f \"${PrjBldDir}EXPORT$Test.make\" $Command$VerboseMacro$KeepgoingMacro";
+			my $Command2 = lc $Command;
+			push @Calls, "make $KeepgoingFlag -f \"${PrjBldDir}export$Test.make\" $Command2$VerboseMacro$KeepgoingMacro";
 		}
 		else {
-			push @Calls, "nmake -nologo -f \"${PrjBldDir}EXPORT$Test.make\" WHAT";
+			push @Calls, "make -sf \"${PrjBldDir}export$Test.make\" what";
 		}
 		@Commands=grep !/EXPORT$/o, @Commands;
 	}
@@ -486,22 +489,24 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 			foreach $LoopBld (@Blds) {
 				my $CFG='';
 				if ($LoopBld ne 'IRRELEVANT') {
-					$CFG=" CFG=$LoopBld";
+					$CFG=" CFG=" . lc $LoopBld;
 				}
 				unless ($Options{what} or $Options{check}) {
 					if ($Program) { # skip programs if they're not supported for a platform
 						unless ($Test) {
-							unless (grep /^$Program$/, @{$Platform::Programs{$Plat}}) {
+							unless (grep /^$Program$/, @{$platform::Programs{$Plat}}) {
 								next PLATFORM;
 							}
 						}
 						else {
-							unless (grep /^$Program$/, @{$Platform::TestPrograms{$Plat}}) {
+							unless (grep /^$Program$/, @{$platform::TestPrograms{$Plat}}) {
 								next PLATFORM;
 							}
 						}
 					}
-					push @Calls, "nmake -nologo$KeepgoingFlag -f \"$PrjBldDir$Plat$Test.make\" $Command$Program$CFG$Source$VerboseMacro$KeepgoingMacro";
+					my $lc_command = lc $Command;
+					my $lc_plat = lc $Plat;
+					push @Calls, "make $KeepgoingFlag -f \"$PrjBldDir$lc_plat$Test.make\" $lc_command$Program$CFG$Source" . "$VerboseMacro$KeepgoingMacro";
 					next;
 				}
 				unless (${$Commands{$Command}}{what}) {
@@ -509,23 +514,26 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 				}
 				if ($Program) { # skip programs if they're not supported for a platform
 					unless ($Test) {
-						unless (grep /^$Program$/, @{$Platform::Programs{$Plat}}) {
+						unless (grep /^$Program$/, @{$platform::Programs{$Plat}}) {
 							next PLATFORM;
 						}
 					}
 					else {
-						unless (grep /^$Program$/, @{$Platform::TestPrograms{$Plat}}) {
+						unless (grep /^$Program$/, @{$platform::TestPrograms{$Plat}}) {
 							next PLATFORM;
 						}
 					}
 				}
 				my $Makefile='';
 				if ($Command=~/MAKEFILE$/o) {
-					$Makefile='MAKEFILE';
+					$Makefile='makefile';
 				}
-				push @Calls, "nmake -nologo -f \"$PrjBldDir$Plat$Test.make\" WHAT$Makefile$Program $CFG";
-			}
-		}
+				my $lcplat = lc $Plat;
+				push @Calls, "make -f \"$PrjBldDir$lcplat$Test.make\" what$Makefile$Program $CFG";
+
+			} # foreach $LoopBld (@Blds)
+
+		} # foreach $Command (@Commands) ?
 	}
 
 
@@ -534,7 +542,6 @@ chdir($BldInfDir) or die "ABLD ERROR: Can't CD to \"$BldInfDir\"\n";
 	my $Call;
 	unless ($Options{what} or $Options{check}) {
 		foreach $Call (@Calls) {
-			print "  $Call\n";
 			open PIPE, "$Call |";
 			while (<PIPE>) {
 				print;
@@ -595,7 +602,7 @@ ENDHERESTRING
 
 	print
 		"project platforms:\n",
-		"   @Platform::Plats\n"
+		"   @platform::Plats\n"
 	;
 	exit 1;
 }
@@ -621,7 +628,7 @@ sub Help ($) {
 
 	my %CommandHash=%{$Commands{$Command}};
 
-	print 'ABLD';
+	print 'abld';
 	unless ($CommandHash{notest}) {
 		print ' [test]';
 	}
diff --git a/aiftool b/aiftool
new file mode 100644
index 0000000..22badef
--- /dev/null
+++ b/aiftool
@@ -0,0 +1,74 @@
+#! /bin/bash
+#
+# aiftool - Unix frontend for aiftool.exe
+#
+# (c) 2001-2002 Alfred E. Heggestad 
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License as published by
+#    the Free Software Foundation; either version 2 of the License, or
+#    (at your option) any later version.
+#
+# Arguments:
+#
+#   $1 input resource filename
+#   $2 input mbmname
+#
+
+usage()
+{
+echo 'AIFTOOL filename mbmname'
+echo 'Use this command to produce an AIF from'
+echo '- a resource file containing language, caption'
+echo '  and capability specifications'
+echo '- a multi-bitmap file containing icons and masks'
+echo '  in various sizes'
+echo 'Specify'
+echo '  filename: the name of the input resource file; the'
+echo '            .rss extension is added by AIFTOOL'
+echo '  mbmname:  the name of the input .mbm file: you'
+echo '            must specify the extension'
+}
+
+echo AIF tool
+
+#
+# check arguments - need at least 2 of them
+#
+if [ $# -lt 2  ] ; then usage ; exit 0 ; fi
+if [ $1 = ""   ] ; then usage ; exit 0 ; fi
+if [ $1 = "/?" ] ; then usage ; exit 0 ; fi
+if [ $1 = "/h" ] ; then usage ; exit 0 ; fi
+if [ $1 = "/H" ] ; then usage ; exit 0 ; fi
+
+
+#
+# compile the resource file
+#
+echo Compiling resource file
+arm-epoc-pe-cpp -I. -I../inc -I../../epoc32/include -I$EPOCROOT/epoc32/include -D_UNICODE < $1.rss > $1.rpp
+wine $EPOCROOT/epoc32/tools/rcomp.exe -D_UNICODE -oaif.rsc -h$1.rs~ -i$1.rss -s$1.rpp
+rm -f $1.rs~
+rm -f $1.rpp
+
+#
+# duplicate mbm file
+#
+cp $2 aif.mbm
+
+
+#
+# run Aiftool
+#
+echo Running AIF writer
+#emxaif aif.rsc $2 -o $1.aif
+wine $EPOCROOT/epoc32/release/winc/udeb/aiftool.exe .
+
+#
+# cleanup
+#
+mv out.aif $1.aif
+#rm -f aif.rsc
+#rm -f aif.mbm
+
+# EOF - aiftool
diff --git a/bldmake b/bldmake
new file mode 100644
index 0000000..3619320
--- /dev/null
+++ b/bldmake
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# bldmake - bash interface for bldmake.pl, part of GnuPoc project
+#
+# (c) 2001 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+perl -S bldmake.pl "$@"
diff --git a/bldmake.pl b/bldmake.pl
index 50a7ba4..f4cd3f5 100644
--- a/bldmake.pl
+++ b/bldmake.pl
@@ -1,3 +1,5 @@
+#!/usr/bin/perl -w
+#
 # BLDMAKE.PL
 #
 # Copyright (c) 1997-1999 Symbian Ltd.  All rights reserved.
@@ -13,12 +15,12 @@ my $PerlLibPath;
 BEGIN {
 # check user has a version of perl that will cope and use bldmake as specified by the system path
 	require 5.003_07;
-	foreach (split ';', $ENV{Path}) {
-		s-/-\\-go;	# for those working with UNIX shells
+	foreach (split ':', $ENV{PATH}) {
+		s-/-\/-go;	# for those working with UNIX shells
 		s-^$-.-o;	# convert empty string to .
-		s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-		if (-e $_.'BLDMAKE.PL') {
-			$PerlLibPath=uc $_;
+		s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a slash
+		if (-e $_.'bldmake.pl') {
+			$PerlLibPath=$_;
 			last;
 		}
 	}
@@ -28,11 +30,11 @@ BEGIN {
 use Getopt::Long;
 
 use lib $PerlLibPath;
-use E32env;
-use E32Plat;
-use Modload;
-use Output;
-use Pathutl;
+use e32env;
+use e32plat;
+use modload;
+use output;
+use pathutl;
 
 my %Options;
 my %KeepGoing;
@@ -71,27 +73,27 @@ my %KeepGoing;
 		eval { &Plat_GetL($CLPlat, \%Plat); };
 		die $@ if $@;
 		print(
-			"Macros defined for BLD.INF preprocessing of MMPFILE sections:\n",
+			"Macros defined for bld.inf preprocessing of MMPFILE sections:\n",
 			"  @{$Plat{MmpMacros}}\n"
 		);
 		exit;
 	}
 
 
-#	check that the BLD.INF file exists
-#	maybe BLDMAKE should allow a path to be specified leading to the BLD.INF file
+#	check that the bld.inf file exists
+#	maybe BLDMAKE should allow a path to be specified leading to the bld.inf file
 	my $BldInfPath=&Path_WorkPath;
-	unless (-e "${BldInfPath}BLD.INF") {
-		&FatalError("Can't find \"${BldInfPath}BLD.INF\"");
+	unless (-e "${BldInfPath}bld.inf") {
+		&FatalError("Can't find \"${BldInfPath}bld.inf\"");
 	}
 
 #	decide the output directory
-	my $OutDir=&Path_Chop($E32env::Data{BldPath}).$BldInfPath;
+	my $OutDir=&Path_Chop($e32env::Data{BldPath}).$BldInfPath;
 
 #	Work out the path for the IBY files
-	my $RomDir=&Path_Chop($E32env::Data{RomPath}).$BldInfPath;
+	my $RomDir=&Path_Chop($e32env::Data{RomPath}).$BldInfPath;
 
-#	Work out the name for the BLD.INF module
+#	Work out the name for the bld.inf module
 	my @Dirs=&Path_Dirs($BldInfPath);
 	my $Module='';
 	foreach (@Dirs) {
@@ -101,7 +103,6 @@ my %KeepGoing;
 
 
 	if ($Command eq 'CLEAN') {
-		unlink "${BldInfPath}ABLD.BAT";
 		$OutDir=~m-(.*)\\-o;
 		if (-d $1) { # remove backslash for test because some old versions of perl can't cope
 			opendir DIR, $1;
@@ -112,23 +113,19 @@ my %KeepGoing;
 		exit;
 	}
 
-#	parse BLD.INF - to get the platforms and the export files
-	eval { &Load_ModuleL('PREPFILE'); };
+#	parse bld.inf - to get the platforms and the export files
+	eval { &Load_ModuleL('prepfile'); };
 	&FatalError($@) if $@;
 
 	my @RealPlats=();
 	my @Exports=();
 	my @TestExports=();
 	if ($Options{v}) {
-		print "Reading \"${BldInfPath}BLD.INF\" for platforms and exports\n";
+		print "Reading \"${BldInfPath}bld.inf\" for platforms and exports\n";
 	}
-	&ParseBldInf(\@RealPlats, \@Exports, \@TestExports, $BldInfPath, 
-		$E32env::Data{EPOCIncPath}, $E32env::Data{EPOCPath});
+	&ParseBldInf(\@RealPlats, \@Exports, \@TestExports, $BldInfPath,
+		$e32env::Data{EPOCIncPath}, $e32env::Data{EPOCPath});
 	
-#	Add WINSCW to the platforms if WINS is defined
-	if (grep /^WINS$/, @RealPlats) {
-		push @RealPlats, 'WINSCW';
-	}
 #	get any IDE platforms required into a new platforms list, and
 #	Create a hash to contain the 'real' names of the platforms, i.e. WINS rather than VC6
 	my @Plats=@RealPlats;
@@ -150,25 +147,25 @@ my %KeepGoing;
 	my @DoPlats=@Plats;
 	unless ($CLPlat eq 'ALL') {
 		unless (grep /^$CLPlat$/, @Plats) {
-			&FatalError("Platform $CLPlat not supported by \"${BldInfPath}BLD.INF\"\n");
+			&FatalError("Platform $CLPlat not supported by \"${BldInfPath}bld.inf\"\n");
 		}
 		@DoPlats=($CLPlat);
 		@DoRealPlats=$Real{$CLPlat};
 	}
 	undef $CLPlat;
-			
+
 #	sort out the export directories we might need to make
-	my @ExportDirs=ExportDirs(\@Exports);
-	my @TestExportDirs=ExportDirs(\@TestExports);
+	my @ExportDirs=&ExportDirs(\@Exports);
+	my @TestExportDirs=&ExportDirs(\@TestExports);
 
-#	parse the BLD.INF file again for each platform supported by the project
+#	parse the bld.inf file again for each platform supported by the project
 #	storing the information in a big data structure
 	my %AllPlatData;
 	my %AllPlatTestData;
 	my $Plat;
 	foreach $Plat (@RealPlats) {
 		if ($Options{v}) {
-			print "Reading \"${BldInfPath}BLD.INF\" for $Plat\n";
+			print "Reading \"${BldInfPath}bld.inf\" for $Plat\n";
 		}
 		my (@PlatData, @PlatTestData);
 		&ParseBldInfPlat(\@PlatData, \@PlatTestData, $Plat, $BldInfPath);
@@ -179,42 +176,45 @@ my %KeepGoing;
 
 	if ($Command eq 'BLDFILES') {
 
-#		create the perl file, PLATFORM.PM, listing the platforms
+#		create the perl file, platform.pm, listing the platforms
 		if ($Options{v}) {
-			print "Creating \"${OutDir}PLATFORM.PM\"\n";
+			print "Creating \"${OutDir}platform.pm\"\n";
 		}
 		&CreatePlatformPm($OutDir, \@Plats, \@RealPlats, \%Real, \%AllPlatData, \%AllPlatTestData);
 
-#		create the .BAT files required to call ABLD.PL
-		if ($Options{v}) {
-			print "Creating \"${BldInfPath}ABLD.BAT\"\n";
-		}
-		&CreatePerlBat($BldInfPath);
+		# Note from alfredh:
+		#
+		#     I removed the creation of the abld shell file
+		#     because it is not necessary. Instead, the file
+		#     is now in /epoc32/tools directory
+		#
 
 #		create the makefile for exporting files
 		if ($Options{v}) {
-			print "Creating \"${OutDir}EXPORT.MAKE\"\n";
+			print "Creating \"${OutDir}export.make\"\n";
 		}
-		&CreateExportMak("${OutDir}EXPORT.MAKE", \@Exports, \@ExportDirs);
+		&CreateExportMak("${OutDir}export.make", \@Exports, \@ExportDirs);
 
 #		create the makefile for exporting test files
 		if ($Options{v}) {
-			print "Creating \"${OutDir}EXPORTTEST.MAKE\"\n";
+			print "Creating \"${OutDir}exporttest.make\"\n";
 		}
-		&CreateExportMak("${OutDir}EXPORTTEST.MAKE", \@TestExports, \@TestExportDirs);
+		&CreateExportMak("${OutDir}exporttest.make", \@TestExports, \@TestExportDirs);
 
 #		create the platform meta-makefiles
 		foreach (@DoPlats) {
 			if ($Options{v}) {
-				print "Creating \"$OutDir$_.MAKE\"\n";
+			  my $tmp = lc $_;
+				print "Creating \"$OutDir$tmp.make\"\n";
 			}
-			&CreatePlatMak($OutDir, $E32env::Data{BldPath}, $AllPlatData{$Real{$_}}, $_, $Real{$_}, $RomDir, $Module);
+			&CreatePlatMak($OutDir, $e32env::Data{BldPath}, $AllPlatData{$Real{$_}}, $_, $Real{$_}, $RomDir, $Module);
 		}
 		foreach (@DoPlats) {
 			if ($Options{v}) {
-				print "Creating \"$OutDir${_}TEST.MAKE\"\n";
+			  my $tmp = lc $_;
+				print "Creating \"$OutDir${tmp}test.make\"\n";
 			}
-			&CreatePlatMak($OutDir, $E32env::Data{BldPath}, $AllPlatTestData{$Real{$_}}, $_, $Real{$_}, $RomDir, $Module, 'TEST');
+			&CreatePlatMak($OutDir, $e32env::Data{BldPath}, $AllPlatTestData{$Real{$_}}, $_, $Real{$_}, $RomDir, $Module, 'TEST');
 		}
 
 #		create the platform test batch files
@@ -228,11 +228,10 @@ my %KeepGoing;
 #		report any near-fatal errors
 		if (scalar keys %KeepGoing) {
 		    print STDERR
-			    "\n${BldInfPath}BLD.INF WARNING(S):\n",
+			    "\n${BldInfPath}bld.inf WARNING(S):\n",
 			    sort keys %KeepGoing
 			    ;
 		}
-
 		exit;
 	}
 }
@@ -248,7 +247,7 @@ my %KeepGoing;
 
 sub Usage () {
 
-	eval { &Load_ModuleL('E32TPVER'); };
+	eval { &Load_ModuleL('e32tpver'); };
 	&FatalError($@) if $@;
 
 	print
@@ -260,7 +259,7 @@ sub Usage () {
 		"<command>: (case insensitive)\n",
 		" BLDFILES - create build batch files\n",
 		" CLEAN    - remove all files bldmake creates\n",
-		" INF      - display basic BLD.INF syntax\n",
+		" INF      - display basic bld.inf syntax\n",
 		" PLAT     - display platform macros\n",
 		"\n",
 		"<platform>: (case insensitive)\n",
@@ -277,7 +276,7 @@ sub ShowBldInfSyntax () {
 
 	print <<ENDHERE;
 
-BLD.INF - Syntax
+bld.inf - Syntax
 
 /* Use C++ comments if required */
 // (Curly braces denote optional arguments)
@@ -295,7 +294,7 @@ PRJ_EXPORTS
 PRJ_TESTEXPORTS
 [<source path>\<source file>]	{<destination>}
 // list each file exported from source on a separate line
-// {<destination>} defaults to BLD.INF dir
+// {<destination>} defaults to bld.inf dir
 
 PRJ_MMPFILES
 [<mmp path>\<mmp file>] {tidy} {ignore}
@@ -330,7 +329,7 @@ sub ParseBldInf ($$$$$) {
 	my ($PlatsRef, $ExportsRef, $TestExportsRef, $BldInfPath, $EPOCIncPath, $EPOCPath)=@_;
 
 	my @Prj2D;
-	eval { &Prepfile_ProcessL(\@Prj2D, "${BldInfPath}BLD.INF"); };
+	eval { &Prepfile_ProcessL(\@Prj2D, "${BldInfPath}bld.inf"); };
 	&FatalError($@) if $@;
 	
 	my @SupportedPlats=&Plat_List();
@@ -347,10 +346,11 @@ sub ParseBldInf ($$$$$) {
 	my $Section=0;
 	my @PrjFileDie;
 	my $Line;
-	my $CurFile="${BldInfPath}BLD.INF";
+	my $CurFile="${BldInfPath}bld.inf";
 	LINE: foreach $Line (@Prj2D) {
 		my $LineNum=shift @$Line;
 		$_=shift @$Line;
+		$_=~s/\\/\//g; # backwards comp - convert backslash to forward slash
 		if ($LineNum eq '#') {
 			$CurFile=$_;
 			next LINE;
@@ -376,9 +376,9 @@ sub ParseBldInf ($$$$$) {
 			unshift @$Line, $_;
 			my $Candidate;
 			CANDLOOP: foreach $Candidate (@$Line) {
-				$Candidate=uc $Candidate;
+				$Candidate=lc $Candidate;
 #				expand DEFAULT
-				if ($Candidate eq 'DEFAULT') {
+				if ($Candidate eq 'default') {
 					$DefaultPlatsUsed=1;
 					my $Default;
 					foreach $Default (@DefaultPlats) {
@@ -406,12 +406,12 @@ sub ParseBldInf ($$$$$) {
 					next CANDLOOP;
 				}
 #				check platform is supported
-				unless (grep /^$Candidate$/, @SupportedPlats) {
+				unless (grep /^$Candidate$/i, @SupportedPlats) {
 					WarnOrDie(\@PrjFileDie, "$CurFile($LineNum) : Unsupported platform $Candidate specified\n");
 					next CANDLOOP;
 				}
 #				check platform is not an IDE
-				if ($Candidate=~/^VC/o) {
+				if ($Candidate=~/^vc/o) {
 					push @PrjFileDie, "$CurFile($LineNum) : No need to specify platform $Candidate here\n";
 					next CANDLOOP;
 				}
@@ -431,6 +431,7 @@ sub ParseBldInf ($$$$$) {
 			if (@$Line) {
 #				get the destination file if it's specified
 				$Releasable=shift @$Line;
+				$Releasable=~s/\\/\//g; # backwards comp - convert backslash to forward slash
 			}
 			if (@$Line) {
 				push @PrjFileDie, "$CurFile($LineNum) : Too many arguments in exports section line\n";
@@ -475,7 +476,7 @@ sub ParseBldInf ($$$$$) {
 	}
 	if (@PrjFileDie) {
 		print STDERR
-			"\n${BldInfPath}BLD.INF FATAL ERROR(S):\n",
+			"\n${BldInfPath}bld.inf FATAL ERROR(S):\n",
 			@PrjFileDie
 		;
 		exit 1;
@@ -526,14 +527,14 @@ sub ExportDirs ($) {
 sub ParseBldInfPlat ($$$$) {
 	my ($DataRef, $TestDataRef, $Plat, $BldInfPath)=@_;
 
-#	get the platform .MMP macros
+#	get the platform .mmp macros
 	my %Plat;
 	eval { &Plat_GetL($Plat,\%Plat); };
 	&FatalError($@) if $@;
 
-#	get the raw data from the BLD.INF file
+#	get the raw data from the bld.inf file
 	my @Prj2D;
-	eval { &Prepfile_ProcessL(\@Prj2D, "${BldInfPath}BLD.INF", @{$Plat{MmpMacros}}); };
+	eval { &Prepfile_ProcessL(\@Prj2D, "${BldInfPath}bld.inf", @{$Plat{MmpMacros}}); };
 	&FatalError($@) if $@;
 	
 #	process the raw data
@@ -541,7 +542,7 @@ sub ParseBldInfPlat ($$$$) {
 	my $Section=0;
 	my @PrjFileDie;
 	my $Line;
-	my $CurFile="${BldInfPath}BLD.INF";
+	my $CurFile="${BldInfPath}bld.inf";
 	LINE: foreach $Line (@Prj2D) {
 
 		my %Data;
@@ -552,38 +553,37 @@ sub ParseBldInfPlat ($$$$) {
 			$CurFile=shift @$Line;
 			next LINE;
 		}
-		
-#		upper-case all the data here
-		foreach (@$Line) {
-			$_=uc $_;
-		}
 
 		$_=shift @$Line;
 
 #		check for section headers - don't test for the right ones here
 #		because we do that in the first parse function
 
-		if (/^PRJ_(\w*)$/o) {
-			$Section=$1;
+		if (/^PRJ_(\w*)$/oi) {
+			$Section=uc $1;
 			next LINE;
 		}
 
-#		check for the sections we're interested in and get the .MMP file details
+#		check for the sections we're interested in and get the .mmp file details
 		if ($Section=~/^(MMPFILES|TESTMMPFILES)$/o) {
 
-			$Data{Ext}='.MMP';
+			$Data{Ext}='.mmp';
 
 #			check for MAKEFILE statements for custom building
-			if (/^MAKEFILE$/o) {
-				$Data{Makefile}=1;
+			if (/^MAKEFILE$/io) {
+			  printf "WARNING: custom NMAKE makefiles not supported! use GNUMAKEFILE instead\n";
+#				$Data{Makefile}=1;
 				$_=shift @$Line;
-				$Data{Ext}=&Path_Split('Ext', $_);
+#				$Data{Ext}=&Path_Split('Ext', $_);
+			  next LINE;
 			}
+
+			$_=~s/\\/\//g; # convert backslash to forward slash
 			
 #			path considered relative to the group directory
 			$Data{Path}=&Path_Split('Path', &Path_MakeAbs($BldInfPath, $_));
 
-#			this function doesn't care whether the .MMPs are listed with their extensions or not
+#			this function doesn't care whether the .mmp's are listed with their extensions or not
 			$Data{Base}=&Path_Split('Base', $_);
 
 #			check the file isn't already specified
@@ -593,6 +593,8 @@ sub ParseBldInfPlat ($$$$) {
 			}
 			$Check{$Data{Base}}="$CurFile: $LineNum";
 
+		        $Data{Base}=~s/\\/\//g;      # force to forward slash
+
 #			check the file exists
 			unless (-e "$Data{Path}$Data{Base}$Data{Ext}") {
 				WarnOrDie(\@PrjFileDie, "$CurFile($LineNum) : $Data{Path}$Data{Base}$Data{Ext} does not exist\n");
@@ -602,6 +604,7 @@ sub ParseBldInfPlat ($$$$) {
 #			process the file's attributes
 			if ($Section eq 'MMPFILES') {
 				foreach (@$Line) {
+				  $_ = uc $_; # alfredh: hack
 					if (/^TIDY$/o) {
 						$Data{Tidy}=1;
 						next;
@@ -609,13 +612,14 @@ sub ParseBldInfPlat ($$$$) {
 					if (/^IGNORE$/o) {
 						next LINE;
 					}
-					push @PrjFileDie, "$CurFile($LineNum) : Don't understand .MMP file argument \"$_\"\n";
+					push @PrjFileDie, "$CurFile($LineNum) : Don't understand .mmp file argument \"$_\"\n";
 				}
 			}
 
-#			process the test .MMP file's attributes
+#			process the test .mmp file's attributes
 			elsif ($Section eq 'TESTMMPFILES') {
 				foreach (@$Line) {
+				  $_ = uc $_; # alfredh: hack
 					if (/^TIDY$/o) {
 						$Data{Tidy}=1;
 						next;
@@ -631,7 +635,7 @@ sub ParseBldInfPlat ($$$$) {
 						$Data{Support}=1;
 						next;
 					}
-					push @PrjFileDie, "$CurFile($LineNum) : Don't understand test .MMP file argument \"$_\"\n";
+					push @PrjFileDie, "$CurFile($LineNum) : Don't understand test .mmp file argument \"$_\"\n";
 				}
 			}
 
@@ -652,7 +656,7 @@ sub ParseBldInfPlat ($$$$) {
 #	exit if there are errors
 	if (@PrjFileDie) {
 		print STDERR
-			"\n\"${BldInfPath}BLD.INF\" FATAL ERROR(S):\n",
+			"\n\"${BldInfPath}bld.inf\" FATAL ERROR(S):\n",
 			@PrjFileDie
 		;
 		exit 1;
@@ -670,12 +674,14 @@ sub CreatePlatformPm ($$$$$$) {
 	my ($BatchPath, $PlatsRef, $RealPlatsRef, $RealHRef, $AllPlatDataHRef, $AllPlatTestDataHRef)=@_;
 
 	&Output(
-		"# Bldmake-generated perl file - PLATFORM.PM\n",
+		"#!/usr/bin/perl -w\n",
+		"#\n",
+		"# Bldmake-generated perl file - platform.pm\n",
 		"\n",
 		"# use a perl integrity checker\n",
 		"use strict;\n",
 		"\n",
-		"package Platform;\n",
+		"package platform;\n",
 		"\n",
 		"use vars qw(\@Plats \@RealPlats %Programs %TestPrograms);\n",
 		"\n",
@@ -746,85 +752,50 @@ sub CreatePlatformPm ($$$$$$) {
 		"1;\n"
 	);
 
-#	write the PLATFORM.PM file
-	&WriteOutFileL($BatchPath."PLATFORM.PM");
-}
-
-sub CreatePerlBat ($) {
-	my ($BldInfPath)=@_;
-
-
-#	create ABLD.BAT, which will call ABLD.PL
-	&Output(
-		"\@ECHO OFF\n",
-		"\n", 
-		"REM Bldmake-generated batch file - ABLD.BAT\n",
-		"REM ** DO NOT EDIT **", 
-		"\n",
-		"\n",
-		"perl -S ABLD.PL ${BldInfPath} %1 %2 %3 %4 %5 %6 %7 %8 %9\n",
-		"if errorlevel==1 goto CheckPerl\n",
-		"goto End\n",
-		"\n",
-		":CheckPerl\n",
-		"perl -v >NUL\n",
-		"if errorlevel==1 echo Is Perl, version 5.003_07 or later, installed?\n",
-		"goto End\n",
-		"\n",
-		":End\n"
-	);
-
-#	check that the .BAT file does not already exist and is read-only
-	if ((-e "${BldInfPath}ABLD.BAT")  && !(-w "${BldInfPath}ABLD.BAT")) {
-		warn "BLDMAKE WARNING: read-only ABLD.BAT will be overwritten\n";
-		chmod 0222, "${BldInfPath}ABLD.BAT";
-	}
-
-#	create the .BAT file in the group directory
-	&WriteOutFileL($BldInfPath."ABLD.BAT",1);
-
+#	write the platform.pm file
+	&WriteOutFileL($BatchPath."platform.pm");
 }
 
 sub CreateExportMak ($$$) {
 	my ($Makefile, $ExportsRef, $ExpDirsRef)=@_;
 
-#	create EXPORT.MAKE
+#	create export.make
 
 	&Output(
-		"!if \"\$(OS)\" == \"Windows_NT\"\n",
-		"ERASE = \@erase 2>>nul\n",
-		"!else\n",
-		"ERASE = \@erase\n",
-		"!endif\n",
+		"#\n",
+		"#   this makefile is for GNU make\n",
+		"#   generated by GnuPoc - EPOC SDK for GNU/Linux\n",
+		"#\n",
+		"ERASE = \@rm -f\n",
 		"\n",
 		"\n",
-		"EXPORT : EXPORTDIRS"
+		"export: exportdirs"
 	);
 	my $ref;
 	if (@$ExportsRef) {
 		foreach $ref (@$ExportsRef) {
 			&Output(
 				" \\\n",
-				"	\"$$ref{Releasable}\""
+				"	$$ref{Releasable}"
 			);
 		}
 	}
 	else {
 		&Output(
 			" \n",
-			"	\@echo Nothing to do\n"
+			"\t\@echo Nothing to do\n"
 		);
 	}
 	&Output(
 		"\n",
 		"\n",
 		"\n",
-		"EXPORTDIRS :"
+		"exportdirs:"
 	);
 	my $dir;
 	foreach $dir (@$ExpDirsRef) {
 		&Output(
-			" \"$dir\""
+			" $dir"
 		);
 	}
 	&Output(
@@ -833,8 +804,8 @@ sub CreateExportMak ($$$) {
 	);
 	foreach $dir (@$ExpDirsRef) {
 		&Output(
-			"\"$dir\" :\n",
-			"	md \"$dir\"\n",
+			"$dir :\n",
+			"\t\@mkdir -p $dir\n",
 			"\n"
 		);
 	}
@@ -844,32 +815,32 @@ sub CreateExportMak ($$$) {
 	);
 	foreach $ref (@$ExportsRef) {
 		&Output(
-			"\"$$ref{Releasable}\" : \"$$ref{Source}\"\n",
-			"	copy \"$$ref{Source}\" \"$$ref{Releasable}\"\n",
+			"$$ref{Releasable} : $$ref{Source}\n",
+			"	\@cp -f $$ref{Source} $$ref{Releasable}\n",
 			"\n"
 		);
 	}
 	&Output(
 		"\n",
 		"\n",
-		"CLEANEXPORT :\n"
+		"cleanexport :\n"
 	);
 	if (@$ExportsRef) {
 		foreach $ref (@$ExportsRef) {
 			&Output(
-				"	\$(ERASE) \"$$ref{Releasable}\"\n"
+				"\t\$(ERASE) $$ref{Releasable}\n"
 			);
 		}
 	}
 	else {
 		&Output(
-			"	\@echo Nothing to do\n"
+			"\t\@echo Nothing to do\n"
 		);
 	}
 	&Output(
 		"\n",
 		"\n",
-		"WHAT :\n"
+		"what :\n"
 	);
 	foreach $ref (@$ExportsRef) {
 		&Output(
@@ -877,7 +848,7 @@ sub CreateExportMak ($$$) {
 		);
 	}
 	
-#	write EXPORT.MAKE
+#	write export.make
 	&WriteOutFileL($Makefile);
 }
 
@@ -889,27 +860,24 @@ sub CreatePlatMak ($$$$$$$$) {
 		$Test='';
 	}
 	else {
-		$Test='TEST';
+		$Test='test';
 	}
 
-	my $OutRomFile="$RomDir$RealPlat$Test.IBY";
-	my $GCCDir="gcc\\bin";
-	
+	my $OutRomFile="$RomDir$RealPlat$Test.iby";
+
 	&Output(
-		"\n",	# set path here for custom builds using GCC
-		'PATH=',&main::Path_Drive,$E32env::Data{EPOCPath},$GCCDir,";\$(PATH)\n",
+		"#\n",
+		"#   this makefile is for GNU make\n",
+		"#   generated by GnuPoc - EPOC SDK for GNU/Linux\n",
+		"#\n",
 		"\n",
-		"!if \"\$(OS)\" == \"Windows_NT\"\n",
-		"ERASE = \@erase 2>>nul\n",
-		"!else\n",
-		"ERASE = \@erase\n",
-		"!endif\n",
+		"ERASE = \@rm -Rf\n",
 		"\n",
 		"\n"
 	);
 	my $Command;
 	my $Ref;
-	foreach $Command (qw(CLEAN CLEANMAKEFILE FINAL FREEZE LIBRARY MAKEFILE RESOURCE SAVESPACE TARGET LISTING WHATMAKEFILE)) {
+	foreach $Command (qw(clean cleanmakefile final freeze library makefile resource savespace target listing whatmakefile)) {
 		&Output(
 			"$Command :"
 		);
@@ -922,8 +890,8 @@ sub CreatePlatMak ($$$$$$$$) {
 		}
 		else {
 			&Output(
-				"	\n",
-				"	\@echo Nothing to do\n"
+				"\n",
+				"\t\@echo Nothing to do\n"
 			);
 		}
 		&Output(
@@ -932,24 +900,24 @@ sub CreatePlatMak ($$$$$$$$) {
 		);
 	}
 	&Output(
-		"WHAT :"
+		"what :"
 	);
 	foreach $Ref (@$DataRef) {
 		unless ($$Ref{Tidy}) {
 			&Output(
-				" WHAT$$Ref{Base}"
+				" what$$Ref{Base}"
 			);
 		}
 	}
 	&Output(
 		"\n",
 		"\n",
-		"TIDY :"
+		"tidy :"
 	);
 	my $Tidy='';
 	foreach $Ref (@$DataRef) {
 		if ($$Ref{Tidy}) {
-			$Tidy.=" TIDY$$Ref{Base}";
+			$Tidy.=" tidy$$Ref{Base}";
 		}
 	}
 	if ($Tidy) {
@@ -960,7 +928,7 @@ sub CreatePlatMak ($$$$$$$$) {
 	else {
 		&Output(
 			"\n",
-			"	\@echo Nothing to do\n"
+			"\t\@echo Nothing to do\n"
 		);
 	}
 	&Output(
@@ -970,25 +938,25 @@ sub CreatePlatMak ($$$$$$$$) {
 #	hack for non-EPOC platforms
 	if ($RealPlat=~/^(WINS|WINC|TOOLS)$/o) {
 		&Output(
-			"ROMFILE :\n"
+			"romfile :\n"
 		);
 	}
 	else {
 		&Output(
-			'ROMFILE : STARTROMFILE'
+			'romfile : startromfile'
 		);
 		foreach $Ref (@$DataRef) {
 			&Output(
-				" ROMFILE$$Ref{Base}"
+				" romfile$$Ref{Base}"
 			);
 		}
 		&Output(
 			"\n",
 			"\n",
-			"STARTROMFILE :\n",
-			"	\@perl -S emkdir.pl \"", &Path_Chop($RomDir), "\"\n",
-			"	\@echo // $OutRomFile > $OutRomFile\n",
-			"	\@echo // >> $OutRomFile\n"
+			"startromfile :\n",
+			    "\t\@mkdir -p \"", &Path_Chop($RomDir), "\"\n",
+			    "\t\@echo // $OutRomFile > $OutRomFile\n",
+			    "\t\@echo // >> $OutRomFile\n"
 		);
 		if ($Test) {
 			my ($Auto, $Manual);
@@ -1014,89 +982,91 @@ sub CreatePlatMak ($$$$$$$$) {
 		"\n",
 		"\n"
 	);
-	my $CallNmake='nmake -nologo $(VERBOSE) $(KEEPGOING) -f';
+	my $CallNmake='@make $(VERBOSE) $(KEEPGOING) -f';
+#	my $CallNmakeSmp='make -j 2 $(VERBOSE) $(KEEPGOING) -f';
+	my $CallNmakeSmp='@make $(VERBOSE) $(KEEPGOING) -f'; # TODO for kursk
 	foreach $Ref (@$DataRef) {
 
 #		standard commands
 		unless ($$Ref{Makefile}) {
-			my $MakefilePath=join('', &Path_Chop($E32MakePath), $$Ref{Path}, $$Ref{Base}, "\\", $RealPlat, "\\");
-			my $RealMakefile="\"$MakefilePath$$Ref{Base}.$RealPlat\"";
-			my $Makefile="\"$MakefilePath$$Ref{Base}";		
+			my $MakefilePath=join('', &Path_Chop($E32MakePath), $$Ref{Path}, $$Ref{Base}, "\/", lc $RealPlat, "\/");
+			my $RealMakefile="$MakefilePath$$Ref{Base}." . lc $RealPlat;
+			my $Makefile="$MakefilePath$$Ref{Base}";
 #			hack for VC6
 			unless ($Plat eq 'VC6') {
-				$Makefile.=".$RealPlat\"";
+				$Makefile.= lc ".$RealPlat";
 			}
 			else {
-				$Makefile.=".DSP\"";
+				$Makefile.=".dsp";
 			}
 			&Output(
-				"MAKEFILE$$Ref{Base} :\n",
-				"	perl -S makmake.pl -D $$Ref{Path}$$Ref{Base} $Plat\n",
+				"makefile$$Ref{Base} :\n",
+				    "\tperl -S makmake.pl -D $$Ref{Path}$$Ref{Base} $Plat\n",
 				"\n",
-				"CLEANMAKEFILE$$Ref{Base} :\n",
-				"	\$(ERASE) $Makefile\n"
+				"cleanmakefile$$Ref{Base} :\n",
+				    "\t\$(ERASE) $Makefile\n"
 			);
 #			hacks for WINS/WINC and VC6
 			if ($RealPlat=~/^(WINS|WINC)$/o) {
 				&Output(
-					"	\$(ERASE) \"$MakefilePath$$Ref{Base}.UID.CPP\"\n"
+					"\t\$(ERASE) \"$MakefilePath$$Ref{Base}.uid.cpp\"\n"
 				);
 			}
 			if ($Plat eq 'VC6') {
 				&Output(
-					"	\$(ERASE) \"$MakefilePath$$Ref{Base}.DSW\"\n",
-					"	\$(ERASE) \"$MakefilePath$$Ref{Base}.SUP.MAKE\"\n"
+					"\t\$(ERASE) \"$MakefilePath$$Ref{Base}.dsw\"\n",
+					"\t\$(ERASE) \"$MakefilePath$$Ref{Base}.sup.make\"\n"
 				);
 			}
 			&Output(
 				"\n",
-				"WHATMAKEFILE$$Ref{Base} :\n",
-				"	\@echo $Makefile\n",
+				"whatmakefile$$Ref{Base} :\n",
+				    "\t\@echo $Makefile\n",
 				"\n",
-				"TARGET$$Ref{Base} :\n",
-				"	$CallNmake $RealMakefile \$(CFG)\n",
+				"target$$Ref{Base} :\n",
+				    "\t$CallNmakeSmp $RealMakefile \$(CFG)\n",
 				"\n",
-				"SAVESPACE$$Ref{Base} :\n",
-				"	$CallNmake $RealMakefile \$(CFG) CLEANBUILD\$(CFG)\n",
+				"savespace$$Ref{Base} :\n",
+				    "\t$CallNmake $RealMakefile \$(CFG) cleanbuild\$(CFG)\n",
 				"\n",
-				"LISTING$$Ref{Base} :\n",
-				"	$CallNmake $RealMakefile LISTING\$(CFG)\$(SOURCE)\n",
+				"listing$$Ref{Base} :\n",
+				    "\t$CallNmake $RealMakefile listing\$(CFG)\$(SOURCE)\n",
 				"\n",
-				"FINAL$$Ref{Base} :\n",
+				"final$$Ref{Base} :\n",
 				"\n",
 			);
-			foreach $Command (qw(CLEAN RESOURCE)) {
+			foreach $Command (qw(clean resource)) {
 				&Output(
 					"$Command$$Ref{Base} :\n",
-					"	$CallNmake $RealMakefile $Command\$(CFG)\n",
+					    "\t$CallNmake $RealMakefile $Command\$(CFG)\n",
 					"\n"
 				);
 			}
-			foreach $Command (qw(FREEZE LIBRARY)) {
+			foreach $Command (qw(freeze library)) {
 				&Output(
 					"$Command$$Ref{Base} :\n",
-					"	$CallNmake $RealMakefile $Command\n",
+					    "\t$CallNmake $RealMakefile $Command\n",
 					"\n"
 				);
 			}
 			unless ($$Ref{Tidy}) {
 				&Output(
-					"WHAT$$Ref{Base} :\n",
-					"	\@$CallNmake $RealMakefile WHAT\$(CFG)\n",
+					"what$$Ref{Base} :\n",
+					"	\@make -s \$(KEEPGOING) -f $RealMakefile what\$(CFG)\n", # -s means silent
 					"\n"
 				);
 			}
 			else {
 				&Output(
-					"TIDY$$Ref{Base} :\n",
-					"	$CallNmake $RealMakefile CLEANRELEASE\n",
-					"	$CallNmake $RealMakefile CLEANLIBRARY\n",
+					"tidy$$Ref{Base} :\n",
+					    "\t$CallNmake $RealMakefile cleanrelease\n",
+					    "\t$CallNmake $RealMakefile cleanlibrary\n",
 					"\n"
 				);
 			}
 			&Output(
-				"ROMFILE$$Ref{Base} :\n",
-				"	\@$CallNmake $RealMakefile ROMFILE >> $OutRomFile\n",
+				"romfile$$Ref{Base} :\n",
+				    "\t$CallNmake $RealMakefile romfile >> $OutRomFile\n",
 				"\n",
 				"\n"
 			);
@@ -1107,77 +1077,78 @@ sub CreatePlatMak ($$$$$$$$) {
 			my $MakefileCall="$CallNmake \"$$Ref{Path}$$Ref{Base}$$Ref{Ext}\"";
 			&Output(
 # should change to MAKEFILE
-				"MAKEFILE$$Ref{Base} :\n",
-				"	$MakefileCall PLATFORM=$Plat MAKMAKE\n",
+				"makefile$$Ref{Base} :\n",
+				    "\t$MakefileCall PLATFORM=$Plat makmake\n",
 				"\n",
 # should call in custom makefiles maybe
-				"CLEANMAKEFILE$$Ref{Base} :\n",
-				"#	$MakefileCall PLATFORM=$Plat CLEANMAKEFILE\n",
+				"cleanmakefile$$Ref{Base} :\n",
+				"#	$MakefileCall PLATFORM=$Plat cleanmakefile\n",
 				"\n",
-				"WHATMAKEFILE$$Ref{Base} :\n",
-				"#	$MakefileCall PLATFORM=$Plat WHATMAKEFILE\n",
+				"whatmakefile$$Ref{Base} :\n",
+				"#	\@$MakefileCall PLATFORM=$Plat whatmakefile\n",
 				"\n",
 # should change to TARGET
-				"TARGET$$Ref{Base} :\n",
-				"	$MakefileCall PLATFORM=$RealPlat CFG=\$(CFG) BLD\n",
+				"target$$Ref{Base} :\n",
+				    "\t$MakefileCall PLATFORM=$RealPlat CFG=\$(CFG) BLD\n",
 				"\n",
 # should ignore this target and just call the TARGET target instead?
-				"SAVESPACE$$Ref{Base} :\n",
-				"	$MakefileCall PLATFORM=$RealPlat CFG=\$(CFG) SAVESPACE\n",
+				"savespace$$Ref{Base} :\n",
+				    "\t$MakefileCall PLATFORM=$RealPlat CFG=\$(CFG) savespace\n",
 				"\n",
-				"LISTING$$Ref{Base} :\n",
+				"listing$$Ref{Base} :\n",
 				"\n",
 				"\n",
 # should change to LIBRARY
-				"LIBRARY$$Ref{Base} :\n",
-				"	$MakefileCall PLATFORM=$RealPlat LIB\n",
+				"library$$Ref{Base} :\n",
+				    "\t$MakefileCall PLATFORM=$RealPlat LIB\n",
 				"\n",
-				"FREEZE$$Ref{Base} :\n",
-				"	$MakefileCall PLATFORM=$RealPlat FREEZE\n",
+				"freeze$$Ref{Base} :\n",
+				    "\t$MakefileCall PLATFORM=$RealPlat FREEZE\n",
 				"\n",
 			);
-			foreach $Command (qw(CLEAN RESOURCE FINAL)) {
+			foreach $Command (qw(clean resource final)) {
 				&Output(
 					"$Command$$Ref{Base} :\n",
-					"	$MakefileCall PLATFORM=$RealPlat CFG=\$(CFG) $Command\n",
+					    "\t$MakefileCall PLATFORM=$RealPlat CFG=\$(CFG) $Command\n",
 					"\n"
 				);
 			}
 			unless ($$Ref{Tidy}) {
 # should change to WHAT
 				&Output(
-					"WHAT$$Ref{Base} :\n",
-					"	\@$MakefileCall PLATFORM=$RealPlat CFG=\$(CFG) RELEASABLES\n",
+					"what$$Ref{Base} :\n",
+					    "\t\@$MakefileCall PLATFORM=$RealPlat CFG=\$(CFG) releasables\n",
 					"\n"
 				);
 			}
 			else {
 				&Output(
-					"TIDY$$Ref{Base} :\n",
-					"	$MakefileCall PLATFORM=$RealPlat TIDY\n",
+					"tidy$$Ref{Base} :\n",
+					    "\t$MakefileCall PLATFORM=$RealPlat tidy\n",
 # should change to CLEANLIBRARY
-					"	$MakefileCall CLEANLIB\n",
+					    "\t$MakefileCall cleanlib\n",
 					"\n"
 				);
 			}
 			&Output(
-				"ROMFILE$$Ref{Base} :\n",
-				"	\@$MakefileCall PLATFORM=$RealPlat ROMFILE >> $OutRomFile\n",
+				"romfile$$Ref{Base} :\n",
+				    "\t\@$MakefileCall PLATFORM=$RealPlat romfile >> $OutRomFile\n",
 				"\n",
 				"\n"
 			);
 		}
 
 	}
-	
-	&WriteOutFileL("$BatchPath$Plat$Test.MAKE");
+
+	$Plat = lc $Plat;
+	&WriteOutFileL("$BatchPath$Plat$Test.make");
 }
 
 sub CreatePlatBatches ($$$) {
 	my ($OutDir, $DataRef, $Plat)=@_;
 
 #	create the test batch files
-#	this function won't work properly if the target basename is different from the .MMP basename
+#	this function won't work properly if the target basename is different from the .mmp basename
 #	so perhaps it should call makmake on the .mmp file to check
 
 	my $AutoText;
@@ -1199,12 +1170,12 @@ sub CreatePlatBatches ($$$) {
 
 	if ($AutoText) {
 		&Output($AutoText);
-		&WriteOutFileL("$OutDir$Plat.AUTO.BAT");
+		&WriteOutFileL("$OutDir$Plat.auto.bat"); # todo
 	}
 
 	if ($ManualText) {
 		&Output($ManualText);
-		&WriteOutFileL("$OutDir$Plat.MANUAL.BAT");
+		&WriteOutFileL("$OutDir$Plat.manual.bat"); # todo
 	}
 }
 
diff --git a/bmconv b/bmconv
new file mode 100644
index 0000000..f01264f
--- /dev/null
+++ b/bmconv
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# bmconv - bash frontend for bmconv.exe, part of GnuPoc project
+#
+# (c) 2001 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+PGM=`basename $0`
+echo "executing $PGM.exe"
+ROOT=$EPOCROOT/epoc32/tools
+wine $ROOT/$PGM.exe "$@"
diff --git a/checkgcc.pm b/checkgcc.pm
index f6dbd83..80fea84 100644
--- a/checkgcc.pm
+++ b/checkgcc.pm
@@ -1,3 +1,5 @@
+#!/usr/bin/perl -w
+#
 # CHECKGCC.PM
 #
 # Copyright (c) 1997-1999 Symbian Ltd.  All rights reserved.
@@ -10,18 +12,17 @@ package CheckGcc;
 
 
 BEGIN {
-	# die if CPP.EXE in a dodgy place in the path
-	my @Paths=split ';', $ENV{Path};
+	# die if CPP in a dodgy place in the path
+	my @Paths=split ':', $ENV{PATH};
 	unshift @Paths,'.';	# add the current directory
 	foreach (@Paths) {
-		s-/-\\-go;	# for those working with UNIX shells
-		s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-		if ((-e $_.'CPP.EXE') or (-e $_.'CPP.BAT') or (-e $_.'CPP.CMD')) {
-			unless (/\\GCC\\BIN\\$/i) {
+		s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a slash
+		if ((-e $_.'arm-epoc-pe-cpp')) {
+			unless (/\/bin\/$/i) {
 				die
 					"ERROR: First CPP executable found in path is in $_,\n",
-					"but the required CPP.EXE was expected to be found in a directory\n",
-					"with a name ending in \\GCC\\BIN\\, where the Cygnus tools\n",
+					"but the required CPP was expected to be found in a directory\n",
+					"with a name ending in /usr/bin/, where the Cygnus tools\n",
 					"this program depends upon are stored.\n",
 					"Is your path set up correctly?\n"
 				;
diff --git a/cjpeg b/cjpeg
new file mode 100644
index 0000000..32db777
--- /dev/null
+++ b/cjpeg
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# cjpeg - bash frontend for cjpeg.exe, part of GnuPoc project
+#
+# (c) 2001 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+PGM=`basename $0`
+echo "executing $PGM.exe"
+ROOT=$EPOCROOT/epoc32/tools
+wine $ROOT/$PGM.exe "$@"
diff --git a/cl_gcc.pm b/cl_gcc.pm
index 0f77506..ffa9a1e 100644
--- a/cl_gcc.pm
+++ b/cl_gcc.pm
@@ -1,13 +1,17 @@
+#!/usr/bin/perl -w
+#
 # CL_GCC.PM
 #
-# Copyright (c) 1997-2000 Symbian Ltd.  All rights reserved.
+# Copyright (c) 1997-2001 Symbian Ltd.  All rights reserved.
+#
+# patched by GnuPoc to generate GNU make files instead of nmake files
 #
 
 
-package Cl_gcc;
+package cl_gcc;
 
-my $GccPrefix='';
-my $ToolPrefix='';
+my $GccPrefix='arm-epoc-pe-';
+my $ToolPrefix='arm-epoc-pe-';
 my $HelperLib='';
 my %PlatOpt=(
 	'Dlltool'=>'',
@@ -15,7 +19,7 @@ my %PlatOpt=(
 	'Gcc'=>'',
 	'Ld'=>'',
 	'Petran'=>'',
-	'Optimize'=>'-O'
+	'Optimize'=>'-O2' # NOTE! -O is default, we prefer -O2 instead
 );
 my $Dlltool;
 my $Archive;
@@ -50,7 +54,6 @@ require Exporter;
 		PMEndSrc
 );
 
-
 sub PMHelp_Mmp {
 	print "// No additional keywords for this platform\n";
 }
@@ -80,7 +83,7 @@ sub PMPlatProcessMmp (@) {
 }
 
 sub PMStartBldList {
-	my $ABI=&main::ABI;
+	my $ABI= lc &main::ABI;
 	my $AifStructRef=&main::AifStructRef;
 	my @BaseResrcList=&main::BaseResrcList;
 	my @BaseSysResrcList=&main::BaseSysResrcList;
@@ -88,8 +91,8 @@ sub PMStartBldList {
 	my $BasicTrgType=&main::BasicTrgType;
 	my $BitMapStructRef=&main::BitMapStructRef;
 	my @BldList=&main::BldList;
-	my @ChopRTWSysIncPaths=&main::Path_Chop(&main::Path_RltToWork(&main::SysIncPaths));
-	my @ChopRTWUserIncPaths=&main::Path_Chop(&main::Path_RltToWork(&main::UserIncPaths));
+	my @ChopRTWSysIncPaths=&main::Path_Chop(&main::SysIncPaths);
+	my @ChopRTWUserIncPaths=&main::Path_Chop(&main::UserIncPaths);
 	my @CompatibleABIs=&main::CompatibleABIs;
 	my $DefFile=&main::DefFile;
 	my $EPOCPath=&main::EPOCPath;
@@ -98,12 +101,12 @@ sub PMStartBldList {
 	my $LibPath=&main::LibPath;
 	my @MacroList=&main::MacroList;
 	my $Plat=&main::Plat;
-	my $RTWASSPLinkPath=&main::Path_RltToWork(&main::ASSPLinkPath);
-	my $RTWBldPath=&main::Path_RltToWork(&main::BldPath);
-	my $RTWLibPath=&main::Path_RltToWork(&main::LibPath);
-	my $RTWLinkPath=&main::Path_RltToWork(&main::LinkPath);
-	my $RTWRelPath=&main::Path_RltToWork(&main::RelPath);
-	my $RTWStatLinkPath=&main::Path_RltToWork(&main::StatLinkPath);
+	my $RTWASSPLinkPath=&main::ASSPLinkPath;
+	my $RTWBldPath=&main::BldPath;
+	my $RTWLibPath=&main::LibPath;
+	my $RTWLinkPath=&main::LinkPath;
+	my $RTWRelPath=&main::RelPath;
+	my $RTWStatLinkPath=&main::StatLinkPath;
 	my $Trg=&main::Trg;
 	my $TrgType=&main::TrgType;
 	my @UidList=&main::UidList;	
@@ -118,7 +121,8 @@ sub PMStartBldList {
 #	set up CompatibleABI lib path hash
 	my %ABILibPath=();
 	foreach (@CompatibleABIs) {
-		$ABILibPath{$_}=&main::Path_Strip("$LibPath..\\$_\\");
+	  my $lcabi = lc $_; # alfredh: hack ARMI->armi, etc
+		$ABILibPath{$_}=&main::Path_Strip("$LibPath..\/$lcabi\/");
 	}
 	my %ABIRTWLibPath=();
 	foreach (@CompatibleABIs) {
@@ -127,44 +131,46 @@ sub PMStartBldList {
 
 #	set up dlltool flag hash
 	my %ABIDlltool=(
-		ARMI=>'-m arm_interwork',
-		ARM4=>'-m arm',
-		THUMB=>'-m thumb'
+		armi=>'-m arm_interwork',
+		arm4=>'-m arm',
+		thumb=>'-m thumb'
 	);
 
 #	work out the flags for various platforms
-	if ($ABI eq 'ARMI') {
+	if ($ABI eq 'armi') {
+		$GccPrefix='arm-epoc-pe-';
 		$PlatOpt{Gcc}='-march=armv4t -mthumb-interwork';
-		$PlatOpt{Dlltool}=$ABIDlltool{ARMI};
+		$PlatOpt{Dlltool}=$ABIDlltool{armi};
 	}
-	elsif ($ABI eq 'ARM4') {
+	elsif ($ABI eq 'arm4') {
 		$PlatOpt{Gcc}='-march=armv4';
-#		allow thumb for ARM4 ABI where necessary
-		unless (&main::PlatABI eq 'ARM4') {
+#		allow thumb for arm4 ABI where necessary
+		unless (&main::PlatABI eq 'arm4') {
 			$PlatOpt{Gcc}.='t';
 		}
-		$PlatOpt{Dlltool}=$ABIDlltool{ARM4};
+		$PlatOpt{Dlltool}=$ABIDlltool{arm4};
 	}
-	elsif ($ABI eq 'THUMB') {
+	elsif ($ABI eq 'thumb') {
 		$GccPrefix='thumb-epoc-pe-';
 		$PlatOpt{Entry}='--thumb-entry';
 		$PlatOpt{Gcc}='-mthumb-interwork';
-		$PlatOpt{Dlltool}=$ABIDlltool{THUMB};
+		$PlatOpt{Dlltool}=$ABIDlltool{thumb};
 #		$HelperLib='up_thumb.lib';
 	}
 	else {
 		&main::FatalError("Platform module - ABI \"$ABI\" unrecognised");
 	}
-	$Dlltool=$ToolPrefix.'dlltool';
+	$Dlltool=$ToolPrefix.'dlltool --as=arm-epoc-pe-as';
 	$Archive=$ToolPrefix.'ar';
 	$Link=$ToolPrefix.'ld';
 	$Objcopy=$ToolPrefix.'objcopy';
-		 
-#	GCC needs a fully-qualified path
+
 	&main::Output(
-		"\n",
-		'PATH=',&main::Path_Drive,$EPOCPath,"gcc\\bin;\$(PATH)\n",
-	);
+		"#\n",
+		"#   this makefile is for GNU make\n",
+		"#   generated by GnuPoc - EPOC SDK for GNU/Linux\n",
+		"#\n",
+		     );
 
 	&main::Output(
 		"\n",
@@ -174,13 +180,7 @@ sub PMStartBldList {
 		"# TargetType $TrgType\n",
 		"# BasicTargetType $BasicTrgType\n",
 		"\n",
-		"\n",
-		"!if \"\$(OS)\" == \"Windows_NT\"\n",
-		"ERASE = \@erase 2>>nul\n",
-		"!else\n",
-		"ERASE = \@erase\n",
-		"!endif\n",
-		"\n",
+		"ERASE = \@rm -Rf\n",
 		"\n",
 		"# EPOC DEFINITIONS\n",
 		"\n"
@@ -191,12 +191,12 @@ sub PMStartBldList {
 	);
 	foreach (@ChopRTWUserIncPaths) {
 		&main::Output(
-			" -I \"$_\""
+			" -I $_"
 		);
 	}
 	foreach (@ChopRTWSysIncPaths) {
 		&main::Output(
-			" -I \"$_\""
+			" -I $_"
 		);
 	}
 	&main::Output(
@@ -224,22 +224,23 @@ sub PMStartBldList {
 	);
 
 	&main::Output(
-		"EPOCBLD = $RTWBldPath #\n",
-		"EPOCTRG = $RTWRelPath #\n",
-		"EPOCLIB = $RTWLibPath #\n",
-		"EPOCLINK = $RTWLinkPath #\n",
-		"EPOCSTATLINK = $RTWStatLinkPath #\n",
-		"EPOCASSPLINK = $RTWASSPLinkPath #\n",
+		"EPOCBLD = $RTWBldPath\n",
+		"EPOCTRG = $RTWRelPath\n",
+		"EPOCLIB = $RTWLibPath\n",
+		"EPOCLINK = $RTWLinkPath\n",
+		"EPOCSTATLINK = $RTWStatLinkPath\n",
+		"EPOCASSPLINK = $RTWASSPLinkPath\n",
 		"\n"
 	);
 	foreach (@BldList) {
-		&main::Output(
-			"EPOCBLD$_ = \$(EPOCBLD)$_\n",
-			"EPOCTRG$_ = \$(EPOCTRG)$_\n",
-			"EPOCLIB$_ = \$(EPOCLIB)UREL\n",
-			"EPOCLINK$_ = \$(EPOCLINK)UREL\n",
-			"EPOCSTATLINK$_ = \$(EPOCSTATLINK)$_\n",
-			"EPOCASSPLINK$_ = \$(EPOCASSPLINK)UREL\n",
+	  my $Bld2 = lc $_;
+		&main::Output(
+			"EPOCBLD$_ = \$(EPOCBLD)$Bld2\n",
+			"EPOCTRG$_ = \$(EPOCTRG)$Bld2\n",
+			"EPOCLIB$_ = \$(EPOCLIB)urel\n",
+			"EPOCLINK$_ = \$(EPOCLINK)urel\n",
+			"EPOCSTATLINK$_ = \$(EPOCSTATLINK)$Bld2\n",
+			"EPOCASSPLINK$_ = \$(EPOCASSPLINK)urel\n",
 			"\n"
 		);
 	}
@@ -253,7 +254,7 @@ sub PMStartBldList {
 		);
 		if (/REL$/o) {
 			&main::Output(
-				      ' -s -fomit-frame-pointer ',
+				      ' -fomit-frame-pointer ',
 				      $PlatOpt{Optimize}
 			);
 		}
@@ -290,25 +291,26 @@ sub PMStartBldList {
 		"\n"
 	);
 	foreach (@BldList) {
+		my $tmp = lc $_;
 		&main::Output(
-			"$_ :"
+			"$tmp:"
 		);
 
 		&main::Output(
 			" \\\n",
-			"\tRESOURCE$_"
+			"\tresource$tmp"
 		);
 
 		&main::Output (
 			" \\\n",
-			"\t\"\$(EPOCTRG$_)\\$Trg\""
+			"\t\$(EPOCTRG$_)\/$Trg"
 		);
 
 #		lib has to come after the main target so that a .DEF file will be generated if the project is not frozen
 		if ($DefFile and not &main::ExportUnfrozen) {
 			&main::Output(
 				" \\\n",
-				"\tLIBRARY\n"
+				"\tlibrary\n"
 			);
 		}
 		&main::Output(
@@ -319,86 +321,91 @@ sub PMStartBldList {
 
 
 	&main::Output(	# ALL comes after REL: because first target in makefile is the default
-		"ALL :"
+		"all:"
 	);
 	foreach (@BldList) {
+	        my $tmp = lc $_;
 		&main::Output(
-			" $_"
+			" $tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"WHAT WHATALL :"
+		"what whatall :"
 	);
 	foreach (@BldList) {
+	  $_ = lc $_;
 		&main::Output(
-			" WHAT$_"
+			" what$_"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"RESOURCE RESOURCEALL :"
+		"resource resourceall :"
 	);
 	foreach (@BldList) {
 		&main::Output(
-			" RESOURCE$_"
+			" resource$_"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"CLEAN CLEANALL : CLEANBUILD CLEANRELEASE CLEANLIBRARY",
+		"clean cleanall: cleanbuild cleanrelease cleanlibrary",
 		"\n",
 		"\n",
-		"CLEANBUILD CLEANBUILDALL :"
+		"cleanbuild cleanbuildall:"
 	);
 	foreach (@BldList) {
+	        my $tmp = lc $_;
 		&main::Output(
-			" CLEANBUILD$_"
+			" cleanbuild$tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"CLEANRELEASE :"
+		"cleanrelease :"
 	);
 	foreach (@BldList) {
+	        my $tmp = lc $_;
 		&main::Output(
-			" CLEANRELEASE$_"
+			" cleanrelease$tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"MAKEWORK : MAKEWORKBUILD MAKEWORKRELEASE MAKEWORKLIBRARY\n",
+		"makework: makeworkbuild makeworkrelease makeworklibrary\n",
 		"\n",
-		"MAKEWORKBUILD :"
+		"makeworkbuild:"
 	);
 	foreach (@BldList) {
+	        my $tmp = lc $_;
 		&main::Output(
-			" MAKEWORKBUILD$_"
+			" makeworkbuild$tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"MAKEWORKRELEASE :"
+		"makeworkrelease:"
 	);
 	foreach (@BldList) {
 		&main::Output(
-			" MAKEWORKRELEASE$_"
+			" makeworkrelease$_"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"LISTING :"
+		"listing :"
 	);
 	foreach (@BldList) {
 		&main::Output(
-			" LISTING$_"
+			" listing$_"
 		);
 	}
 	&main::Output(
@@ -407,16 +414,18 @@ sub PMStartBldList {
 	);
 
 	foreach (@BldList) {
+		$_ = uc $_; # TODO (alfredh) possible bug here, where $_ points to content of @BldList ?
+	        my $tmp = lc $_;
 		&main::Output(
 			"\n",
-			"RESOURCE$_ : MAKEWORK$_"
+			"resource$tmp: makework$tmp"
 		);
 
 		my $BitMapRef;
 		foreach $BitMapRef (@$BitMapStructRef) {
 			&main::Output(
 				" \\\n",
-				"\t\"\$(EPOCTRG$_)\\$$BitMapRef{Trg}\""
+				"\t\$(EPOCTRG$_)\/$$BitMapRef{Trg}"
 			);
 		}
 		undef $BitMapRef;
@@ -427,7 +436,7 @@ sub PMStartBldList {
 			foreach $Lang (@LangList) {
 				&main::Output(	# must come before main target because source for target will depend on the
 					" \\\n",						# *.rsg file in $EPOCIncPath
-					"\t\"\$(EPOCTRG$_)\\$BaseResrc.R$Lang\""
+					"\t\$(EPOCTRG$_)\/$BaseResrc.r$Lang"
 				);
 			}
 		}
@@ -437,7 +446,7 @@ sub PMStartBldList {
 		foreach $AifRef (@$AifStructRef) {
 			&main::Output(
 				" \\\n",
-				"\t\"\$(EPOCTRG$_)\\$$AifRef{Trg}\""
+				"\t\$(EPOCTRG$_)\/$$AifRef{Trg}"
 			);
 		}
 		undef $AifRef;
@@ -452,13 +461,14 @@ sub PMStartBldList {
 	);
 
 	&main::Output(
-		"LIBRARY :"
+		"library :"
 	);
 	if ($BasicTrgType=~/^LIB$/o) {
 #		code to ensure that the static libraries for all builds are built at the library stage
 		foreach (@BldList) {
+			my $tmp = lc $_;
 			&main::Output(
-				" $_"
+				" $tmp"
 			);
 		}
 	}
@@ -466,11 +476,11 @@ sub PMStartBldList {
 		unless (&main::ExportUnfrozen) {
 			if (-e $DefFile) { # effectively "if project frozen ..."
 				&main::Output(
-					" \"\$(EPOCLIB)UREL\\$BaseTrg.LIB\""
+					" \$(EPOCLIB)urel\/$BaseTrg.lib"
 				);
 				foreach (@CompatibleABIs) {
 					&main::Output(
-						" \"$ABILibPath{$_}UREL\\$BaseTrg.LIB\""
+						" $ABILibPath{$_}urel\/$BaseTrg.lib"
 					);
 				}
 				&main::Output(
@@ -488,7 +498,7 @@ sub PMStartBldList {
 		else {
 			&main::Output(
 				"\n",
-				"\t\@echo Not attempting to create \"\$(EPOCLIB)UREL\\$BaseTrg.LIB\"\n",
+				"\t\@echo Not attempting to create \"\$(EPOCLIB)urel\/$BaseTrg.lib\"\n",
 				"\t\@echo from frozen .DEF file, since EXPORTUNFROZEN specified.\n"
 			);
 		}
@@ -497,43 +507,46 @@ sub PMStartBldList {
 			"\n",
 			"# REAL TARGET - LIBRARY\n",
 			"\n",
-			"\"\$(EPOCLIB)UREL\\$BaseTrg.LIB\" : \"$DefFile\" MAKEWORKLIBRARY\n",
-			"\t$Dlltool $PlatOpt{Dlltool} --output-lib \"\$(EPOCLIB)UREL\\$BaseTrg.LIB\" \\\n",
-			"\t\t--def \"",&main::Path_RltToWork($DefFile),"\" \\\n",
-			"\t\t--dllname \"$LinkAs\" \n"
+			"\$(EPOCLIB)urel\/$BaseTrg.lib: $DefFile \$(EPOCLIB)urel\n",
+			"\techo \"$BaseTrg.lib\"\n",
+			"\t$Dlltool $PlatOpt{Dlltool} --output-lib \$(EPOCLIB)urel\/$BaseTrg.lib \\\n",
+			"\t\t--def $DefFile \\\n",
+			"\t\t--dllname $LinkAs \n"
 		);
 		foreach (@CompatibleABIs) {
+			my $dlltool_params = "";
+			$dlltool_params = $ABIDlltool{$_} if($ABIDlltool{$_});
 			&main::Output(
 				"\n",
-				"\"$ABILibPath{$_}UREL\\$BaseTrg.LIB\" : \"$DefFile\" MAKEWORKLIBRARY\n",
-				"\t$Dlltool $ABIDlltool{$_} --output-lib \"$ABIRTWLibPath{$_}UREL\\$BaseTrg.LIB\" \\\n",
-				"\t\t--def \"",&main::Path_RltToWork($DefFile),"\" \\\n",
-				"\t\t--dllname \"$LinkAs\" \n"
+				"$ABILibPath{$_}urel\/$BaseTrg.lib: $DefFile $ABILibPath{$_}urel\n",
+				"\t$Dlltool $dlltool_params --output-lib $ABILibPath{$_}urel\/$BaseTrg.lib \\\n",
+				"\t\t--def $DefFile \\\n",
+				"\t\t--dllname $LinkAs \n"
 			);
 		}
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"FREEZE :\n"
+		"freeze :\n"
 	);
 	if ($DefFile) {
 		&main::Output(
 #			call perl on the script here so nmake will die if there are errors - this doesn't happen if calling perl in a batch file
-			"\tperl -S efreeze.pl \"$DefFile\" \"\$(EPOCBLD)$BaseTrg.def\" \n"
+			"\tperl -S efreeze.pl $DefFile \$(EPOCBLD)$BaseTrg.def \n"
 		);
 	}
 	&main::Output(
 		"\n",
-		"CLEANLIBRARY :\n"
+		"cleanlibrary:\n"
 	);
 	if ($DefFile) {
 		&main::Output(
-			"\t-\$(ERASE) \"\$(EPOCLIB)UREL\\$BaseTrg.*\"\n"
+			"\t-\$(ERASE) \$(EPOCLIB)urel\/$BaseTrg.*\n"
 		);
 		foreach (@CompatibleABIs) {
 			&main::Output(
-				"\t-\$(ERASE) \"$ABILibPath{$_}UREL\\$BaseTrg.*\"\n"
+				"\t-\$(ERASE) $ABILibPath{$_}urel\/$BaseTrg.*\n"
 			);
 		}
 	}
@@ -541,15 +554,15 @@ sub PMStartBldList {
 #so don't put out the targets for making the path here if they're the same
 	&main::Output(
 		"\n",
-		"MAKEWORKLIBRARY :"
+		"makeworklibrary :"
 	);
 	if ($DefFile) {
 		&main::Output(
-			" \"${LibPath}UREL\""
+			" ${LibPath}urel"
 		);
 		foreach (@CompatibleABIs) {
 			&main::Output(
-				" \"$ABILibPath{$_}UREL\""
+				" $ABILibPath{$_}urel"
 			);
 		}
 	}
@@ -560,15 +573,15 @@ sub PMStartBldList {
 	if ($DefFile) {
 		unless ($LibPath eq &main::RelPath) {
 			&main::Output(
-				"\"${LibPath}UREL\" :\n",
-				"\t\@perl -S emkdir.pl \"${LibPath}UREL\"\n",
+				"${LibPath}urel :\n",
+				"\t\@mkdir -p ${LibPath}urel\n",
 				"\n"
 			);
 		}
 		foreach (@CompatibleABIs) {
 			&main::Output(
-				"\"$ABILibPath{$_}UREL\" :\n",
-				"\t\@perl -S emkdir.pl \"$ABILibPath{$_}UREL\"\n",
+				"$ABILibPath{$_}urel :\n",
+				"\t\@mkdir -p $ABILibPath{$_}urel\n",
 				"\n"
 			);
 		}
@@ -597,7 +610,7 @@ sub PMBld {
 	my @CompatibleABIs=&main::CompatibleABIs;
 	my $DefFile=&main::DefFile;
 	my $EPOCIncPath=&main::EPOCIncPath;
-	my $EPOCLocPath=&main::EPOCPath."Localisation\\";
+	my $EPOCLocPath=&main::EPOCPath."localisation/";
 	my $FirstLib=&main::FirstLib;
 	my $BasicTrgType=&main::BasicTrgType;
 	my @LangList=&main::LangList;
@@ -612,6 +625,8 @@ sub PMBld {
 	my $TrgType=&main::TrgType;
 	my @UidList=&main::UidList;
 
+	my $Bld2 = lc $Bld;
+
 	if ($Bld =~ /DEB/) {
 		@LibList = &main::DebugLibList;
 	} else {
@@ -634,22 +649,22 @@ sub PMBld {
 
 #	releasables
 	&main::Output(
-		"RELEASEABLES= \\\n",
-		"\t\"$RelPath$Trg\""
+		"RELEASEABLES",$Bld," = \\\n",
+		"\t$RelPath$Trg"
 	);
 	if ($BasicTrgType=~/^(DLL|EXE)$/o) {
 		&main::Output(
-			" \\\n\t\"$RelPath$Trg.MAP\""
+			" \\\n\t$RelPath$Trg.map"
 		);
 	}
 	my $BitMapRef;
 	foreach $BitMapRef (@$BitMapStructRef) {
 		&main::Output(
-			" \\\n\t\"$RelPath$$BitMapRef{Trg}\""
+			" \\\n\t$RelPath$$BitMapRef{Trg}"
 		);
 		if ($$BitMapRef{Hdr}) {
 			&main::Output(
-				" \\\n\t\"$EPOCIncPath", &main::Path_Split('Base', $$BitMapRef{Trg}), ".MBG\""
+				" \\\n\t$EPOCIncPath", &main::Path_Split('Base', $$BitMapRef{Trg}), ".mbg"
 			);
 		}
 	}
@@ -658,28 +673,29 @@ sub PMBld {
 		my $Lang;
 		foreach $Lang (@LangList) {
 			&main::Output(
-				" \\\n\t\"$RelPath$BaseResrc.R$Lang\""
+				" \\\n\t$RelPath$BaseResrc.r$Lang"
 			);
 		}
 		&main::Output(
-			" \\\n\t\"$EPOCLocPath$BaseResrc.rpp\"",
-			" \\\n\t\"$EPOCIncPath$BaseResrc.RSG\""
+			" \\\n\t$EPOCLocPath$BaseResrc.rpp",
+			" \\\n\t$EPOCIncPath$BaseResrc.rsg"
 		);
 	}
 	my $AifRef;
 	foreach $AifRef (@$AifStructRef) {
 		&main::Output(
-			" \\\n\t\"$RelPath$$AifRef{Trg}\""
+			" \\\n\t$RelPath$$AifRef{Trg}"
 		);
 	}
 	if (-e $DefFile) { # effectively "if project frozen ..."
 		&main::Output(
-			" \\\n\t\"$LibPath$BaseTrg.LIB\""
+			" \\\n\t$LibPath$BaseTrg.lib"
 		);
 		my $ABI;
 		foreach $ABI (@CompatibleABIs) {
+			$ABI = lc $ABI; # AEH hack: ARM4 -> arm4, etc
 			&main::Output(
-				" \\\n\t\"", &main::Path_Strip("$LibPath..\\..\\$ABI\\UREL\\"), "$BaseTrg.LIB\""
+				" \\\n\t", &main::Path_Strip("$LibPath..\/..\/$ABI\/urel\/"), "$BaseTrg.lib"
 			);
 		}
 	}
@@ -689,32 +705,32 @@ sub PMBld {
 	);
 
 	&main::Output(
-		"WHAT$Bld :\n",
-		"\t\@echo \$(RELEASEABLES)\n",
+		"what$Bld2 :\n",
+		"\t\@echo \$(RELEASEABLES",$Bld,")\n",
 		"\n",
-		"CLEAN$Bld : CLEANBUILD$Bld CLEANRELEASE$Bld\n",
+		"clean$Bld2: cleanbuild$Bld2 cleanrelease$Bld2\n",
 		"\n",
-		"CLEANBUILD$Bld : \n",
-		"\t\@perl -S ermdir.pl \"\$(EPOCBLD$Bld)\"\n",
+		"cleanbuild$Bld2: \n",
+		"\t\@rm -rf \$(EPOCBLD$Bld)\n",
 		"\n",
-		"CLEANRELEASE$Bld : \n",
-		"\t-\$(ERASE) \$(RELEASEABLES)\n",
+		"cleanrelease$Bld2: \n",
+		"\t-\$(ERASE) \$(RELEASEABLES",$Bld,")\n",
 		"\n"
 	);
 
 
 	&main::Output(
-		"MAKEWORK$Bld : MAKEWORKBUILD$Bld MAKEWORKRELEASE$Bld\n",
+		"makework$Bld2: makeworkbuild$Bld2 makeworkrelease$Bld2\n",
 		"\n",
-		"MAKEWORKBUILD$Bld : \"$ChopBldPath\"\n",
+		"makeworkbuild$Bld2: $ChopBldPath\n",
 		"\n",
-		"MAKEWORKRELEASE$Bld : \"$ChopRelPath\"\n",
+		"makeworkrelease$Bld2: $ChopRelPath\n",
 		"\n"
 	);
 	foreach ($ChopBldPath, $ChopRelPath) {
 		&main::Output(
-			"\"$_\" : \n",
-			"\t\@perl -S emkdir.pl \"$_\"\n",
+			"$_:\n",
+			"\t\@mkdir -p $_\n",
 			"\n"
 		);
 	}
@@ -723,11 +739,11 @@ sub PMBld {
 	);
 
 	&main::Output(
-		"LISTING$Bld :"
+		"listing$Bld2 :"
 	);
 	foreach (@BaseSrcList) {
 		&main::Output(
-			" \\\n\tLISTING$Bld$_"
+			"\\\n\tlisting$Bld2$_"
 		);
 	}
 	&main::Output(
@@ -736,30 +752,30 @@ sub PMBld {
 	);
 
 	&main::Output(
-		"LIBS="
+		"LIBS",$Bld,"="
 	);
 	if ($HelperLib) {
 		&main::Output(
 			" \\\n",
-			"\t\"\$(EPOCSTATLINK$Bld)\\$HelperLib\""
+			"\t\$(EPOCSTATLINK$Bld)\/$HelperLib"
 		);
 	}
 	foreach (@StatLibList) {
 		&main::Output(
 			" \\\n",
-			"\t\"\$(EPOCSTATLINK$Bld)\\$_\""
+			"\t\$(EPOCSTATLINK$Bld)\/$_"
 		);
 	}
 	foreach (@ASSPLibList) {
 		&main::Output(
 			" \\\n",
-			"\t\"\$(EPOCASSPLINK$Bld)\\$_\""
+			"\t\$(EPOCASSPLINK$Bld)\/$_"
 		);
 	}
 	foreach (@LibList) {
 		&main::Output(
 			" \\\n",
-			"\t\"\$(EPOCLINK$Bld)\\$_\""
+			"\t\$(EPOCLINK$Bld)\/$_"
 		);
 	}
 	&main::Output(
@@ -768,36 +784,39 @@ sub PMBld {
 	);
 
 	&main::Output(
-		"\"\$(EPOCTRG$Bld)\\$Trg\" : \"\$(EPOCBLD$Bld)\\$BaseTrg.in\""
+		"\$(EPOCTRG$Bld)\/$Trg: \$(EPOCBLD$Bld)/$BaseTrg.in"
 	);
 	if (-e $DefFile) { # effectively "if project frozen ..."
 		&main::Output(
-			" \"$DefFile\""
+			" $DefFile"
 		);
 	}
 	if ($BasicTrgType=~/^(EXE|DLL)$/o) {
 		&main::Output(
-			" \"\$(EPOCSTATLINK$Bld)\\$FirstLib\" \"\$(EPOCSTATLINK$Bld)\\EGCC.LIB\""
+			" \$(EPOCSTATLINK$Bld)\/$FirstLib \$(EPOCSTATLINK$Bld)\/egcc.lib"
 		);
 	}
 	if ($BasicTrgType=~/^(DLL)$/o) {	# Add the DLL stub
 		&main::Output(
-			" \"\$(EPOCSTATLINK$Bld)\\EDLLSTUB.LIB\""
+			" \$(EPOCSTATLINK$Bld)\/edllstub.lib"
 		);
 	}
 	&main::Output(
-		" \$(LIBS)\n"
+		" \$(LIBS",$Bld,")\n"
 	);
 
+	&main::Output(
+		"\techo \"$Trg\"\n",
+	);
 	if ($BasicTrgType=~/^DLL$/o || $TrgType=~/^EXEDLL$/o) {
 
 #		generate a .DEF file from the objects and static libraries
 		&main::Output(
-			"\t$Dlltool $PlatOpt{Dlltool} --output-def \"\$(EPOCBLD$Bld)\\$BaseTrg.inf\" \"\$(EPOCBLD$Bld)\\$BaseTrg.in\""
+			"\t$Dlltool $PlatOpt{Dlltool} --output-def \$(EPOCBLD$Bld)\/$BaseTrg.inf \$(OBJECTS$Bld)"
 		);
 		foreach (@StatLibList) {
 			&main::Output(
-				" \"\$(EPOCSTATLINK$Bld)\\$_\""
+				" \$(EPOCSTATLINK$Bld)\/$_"
 			);
 		}
 		&main::Output(
@@ -807,11 +826,11 @@ sub PMBld {
 #		reorder the .DEF file taking frozen exports into account if there are any
 		&main::Output(
 #			call perl on the script here so nmake will die if there are errors - this doesn't happen if calling perl in a batch file
-			"\tperl -S makedef.pl -Deffile \"\$(EPOCBLD$Bld)\\$BaseTrg.inf\""
+			"\tperl -S makedef.pl -Deffile \$(EPOCBLD$Bld)\/$BaseTrg.inf"
 		);
 		if (-e $DefFile) { # effectively "if project frozen ..."
 			&main::Output(
-				" -Frzfile \"$DefFile\""
+				" -Frzfile $DefFile"
 			);
 		}
 		else { # freeze ordinals, a maximum of 2, for polymorphic dlls
@@ -825,24 +844,24 @@ sub PMBld {
 			}
 		}
 		&main::Output(
-			" \"\$(EPOCBLD)$BaseTrg.def\"\n"
+			" \$(EPOCBLD)$BaseTrg.def\n"
 		);
 
 #		delete the unordered definition file
 		&main::Output(
-			"\tdel \"\$(EPOCBLD$Bld)\\$BaseTrg.inf\"\n"
+			"\t\$(ERASE) \$(EPOCBLD$Bld)\/$BaseTrg.inf\n"
 		);
 
 #		generate an export object from the ordered .DEF file
 		&main::Output(
-			"\t$Dlltool $PlatOpt{Dlltool} --def \"\$(EPOCBLD)$BaseTrg.def\" \\\n",
-			"\t\t--output-exp \"\$(EPOCBLD$Bld)\\$BaseTrg.exp\" \\\n",
-			"\t\t--dllname \"$LinkAs\""
+			"\t$Dlltool $PlatOpt{Dlltool} --def \$(EPOCBLD)$BaseTrg.def \\\n",
+			"\t\t--output-exp \$(EPOCBLD$Bld)\/$BaseTrg.exp \\\n",
+			"\t\t--dllname $LinkAs"
 		);
 		if (&main::ExportUnfrozen) {
 			&main::Output(
 				"\\\n",
-				"\t\t--output-lib \"\$(EPOCLIB)UREL\\$BaseTrg.LIB\""
+				"\t\t--output-lib \$(EPOCLIB)urel\/$BaseTrg.lib"
 			);
 		}
 		&main::Output(
@@ -857,7 +876,7 @@ sub PMBld {
 			);	
 		if ($BasicTrgType=~/^DLL$/o) {
 			&main::Output(
-				" $PlatOpt{Entry} _E32Dll -u _E32Dll \"\$(EPOCBLD$Bld)\\$BaseTrg.exp\" --dll \\\n"
+				" $PlatOpt{Entry} _E32Dll -u _E32Dll \$(EPOCBLD$Bld)\/$BaseTrg.exp --dll \\\n"
 			);
 		}
 		elsif ($BasicTrgType=~/^EXE$/o) {
@@ -866,34 +885,32 @@ sub PMBld {
 			);
 		}
 		&main::Output(
-			"\t\t--base-file \"\$(EPOCBLD$Bld)\\$BaseTrg.bas\" -o \"\$(EPOCBLD$Bld)\\$Trg\" \\\n",
-			"\t\t\"\$(EPOCSTATLINK$Bld)\\$FirstLib\" --whole-archive \"\$(EPOCBLD$Bld)\\$BaseTrg.in\" \\\n",
+			"\t\t--base-file \$(EPOCBLD$Bld)\/$BaseTrg.bas -o \$(EPOCBLD$Bld)\/$Trg \\\n",
+			"\t\t\$(EPOCSTATLINK$Bld)\/$FirstLib --whole-archive \$(EPOCBLD$Bld)/$BaseTrg.in \\\n",
 			"\t\t--no-whole-archive"
 		);
 		if ($BasicTrgType=~/^DLL$/o) { # Add the DLL stub
 			&main::Output(
-				" \$(EPOCSTATLINK$Bld)\\EDLLSTUB.LIB"
+				" \$(EPOCSTATLINK$Bld)\/edllstub.lib"
 			);
 		}
 		if ($BasicTrgType=~/^(DLL|EXE)/o) { # Add the GCC helper fns
 			&main::Output(
-				 " \$(EPOCSTATLINK$Bld)\\EGCC.LIB"
+				 " \$(EPOCSTATLINK$Bld)\/egcc.lib"
 			);
 		}
 		&main::Output(
-			" \$(LIBS) \$(USERLDFLAGS)\n"
+			" \$(LIBS",$Bld,") \$(USERLDFLAGS)\n"
 		);
-#		--whole-archive is required here apparently because of a bug in the gcc toolchain
-#		the flag can probably be removed with a later version of gcc
 
 #		delete temporary files
 		if ($BasicTrgType=~/^DLL$/o || $TrgType=~/^EXEDLL$/o) {
 			&main::Output(
-				"\tdel \"\$(EPOCBLD$Bld)\\$BaseTrg.exp\"\n"
+				"\t\$(ERASE) \$(EPOCBLD$Bld)\/$BaseTrg.exp\n"
 			);
 		}
 		&main::Output(
-			"\tdel \"\$(EPOCBLD$Bld)\\$Trg\"\n"
+			"\t\$(ERASE) \$(EPOCBLD$Bld)\/$Trg\n"
 		);
 
 #		call dlltool to do base relocations (and dll exports)
@@ -902,29 +919,24 @@ sub PMBld {
 		);
 		if ($BasicTrgType=~/^DLL$/o || $TrgType=~/^EXEDLL$/o) {
 			&main::Output(
-				"\t\t--def \"\$(EPOCBLD)$BaseTrg.def\" \\\n",
-				"\t\t--dllname \"$LinkAs\" \\\n"
+				"\t\t--def \$(EPOCBLD)$BaseTrg.def \\\n",
+				"\t\t--dllname $LinkAs \\\n"
 			);
 		}
 		&main::Output(
-			"\t\t--base-file \"\$(EPOCBLD$Bld)\\$BaseTrg.bas\" \\\n",
-			"\t\t--output-exp \"\$(EPOCBLD$Bld)\\$BaseTrg.exp\" \n"
+			"\t\t--base-file \$(EPOCBLD$Bld)\/$BaseTrg.bas \\\n",
+			"\t\t--output-exp \$(EPOCBLD$Bld)\/$BaseTrg.exp \n"
 		);
 
 #		delete temporary files
 		&main::Output(
-			"\tdel \"\$(EPOCBLD$Bld)\\$BaseTrg.bas\"\n"
+			"\t\$(ERASE) \$(EPOCBLD$Bld)\/$BaseTrg.bas\n"
 		);
 
 #		call ld to link the target
 		&main::Output(
 			"\t$Link $PlatOpt{Ld}"
 		);
-		if ($Bld=~/^U?REL$/o) {
-			&main::Output(
-				" -s"
-			);
-		}
 		if ($BasicTrgType=~/^DLL$/o) {
 			&main::Output(
 				" $PlatOpt{Entry} _E32Dll -u _E32Dll --dll \\\n"
@@ -936,45 +948,43 @@ sub PMBld {
 			);
 		}
 		&main::Output(
-			"\t\t\"\$(EPOCBLD$Bld)\\$BaseTrg.exp\" \\\n",
-			"\t\t-Map \"\$(EPOCTRG$Bld)\\$Trg.map\" -o \"\$(EPOCBLD$Bld)\\$Trg\" \\\n",
-			"\t\t\"\$(EPOCSTATLINK$Bld)\\$FirstLib\" --whole-archive \"\$(EPOCBLD$Bld)\\$BaseTrg.in\" \\\n",
-			"\t\t--no-whole-archive"
+			"\t\t\$(EPOCBLD$Bld)\/$BaseTrg.exp \\\n",
+			"\t\t-Map \$(EPOCTRG$Bld)\/$Trg.map -o \$(EPOCBLD$Bld)\/$Trg \\\n",
+			"\t\t\$(EPOCSTATLINK$Bld)\/$FirstLib \$(OBJECTS",$Bld,") \\\n"
 		);
 		if ($BasicTrgType=~/^DLL$/o) { # Add the DLL stub
 			&main::Output(
-				" \$(EPOCSTATLINK$Bld)\\EDLLSTUB.LIB"
+				" \$(EPOCSTATLINK$Bld)\/edllstub.lib"
 			);
 		}
 		if ($BasicTrgType=~/^(DLL|EXE)/o) { # Add the GCC helper fns
 			&main::Output(
-				 " \$(EPOCSTATLINK$Bld)\\EGCC.LIB"
+				 " \$(EPOCSTATLINK$Bld)\/egcc.lib"
 			);
 		}
 		&main::Output(
-			" \$(LIBS) \$(USERLDFLAGS)\n"
+			" \$(LIBS",$Bld,") \$(USERLDFLAGS)\n"
 		);
-#		--whole-archive is required here apparently because of a bug in the gcc toolchain
-#		the flag can probably be removed with a later version of gcc
 
 #		delete temporary files
 		&main::Output(
-			"\tdel \"\$(EPOCBLD$Bld)\\$BaseTrg.exp\"\n"
+			"\t\$(ERASE) \$(EPOCBLD$Bld)\/$BaseTrg.exp\n"
 		);
 
 		if ($Bld=~/^U?DEB$/o) {
 			&main::Output(
-				"\t$Objcopy -X \"\$(EPOCBLD$Bld)\\$Trg\" \"\$(EPOCTRG$Bld)\\$BaseTrg.sym\"\n"
+				"\t$Objcopy -X \$(EPOCBLD$Bld)\/$Trg \$(EPOCTRG$Bld)\/$BaseTrg.sym\n"
 			);
 		}
 
 		&main::Output(
-			"\tpetran $PlatOpt{Petran} \"\$(EPOCBLD$Bld)\\$Trg\" \$\@ \\\n",
-			"\t\t"
-		);
+			      "\tpetran $PlatOpt{Petran} \$(EPOCBLD$Bld)\/$Trg \$\@ \\\n",
+			      "\t\t"
+			     );
+
 		if (&main::AllowDllData) {
 			&main::Output(
-				' -allow'
+				' -allowdlldata' # bugfix (was -allow)
 			);
 		}
 		if (not &main::CallDllEntryPoints) {
@@ -1019,12 +1029,12 @@ sub PMBld {
 			"\n"
 		);
 		&main::Output(
-			"\tdel \"\$(EPOCBLD$Bld)\\$Trg\"\n"
+			"\t\$(ERASE) \$(EPOCBLD$Bld)\/$Trg\n"
 		);
 	}
 	elsif ($BasicTrgType=~/^LIB$/o) {
 		&main::Output(
-			"\tcopy \"\$(EPOCBLD$Bld)\\$BaseTrg.in\" \"\$(EPOCSTATLINK$Bld)\\$Trg\"\n"
+			"\tcp \$(EPOCBLD$Bld)\/$BaseTrg.in \$(EPOCSTATLINK$Bld)\/$Trg\n"
 		);
 	}
 
@@ -1036,11 +1046,11 @@ sub PMBld {
 	# TARGET *.IN
 	#------------
 	&main::Output(
-		"OBJECTS="
+		"OBJECTS",$Bld,"="
 	);
 	foreach (@BaseSrcList) {
 		&main::Output(
-			" \\\n\t\$(EPOCBLD$Bld)\\$_.o"
+			" \\\n\t\$(EPOCBLD$Bld)\/$_.o"
 		);	# would have quotes round these for longfilenames if ar didn't complain.  OK because not referred to as having quotes
 	}
 	&main::Output(
@@ -1048,18 +1058,11 @@ sub PMBld {
 		"\n"
 	);
 	&main::Output(
-		"\"\$(EPOCBLD$Bld)\\$BaseTrg.in\" : \$(OBJECTS)\n",	# MUST have quotes round .in file else file not thought of as a depend
-		"\tif exist \$\@ del \$\@\n",
-		"\tcd \"\$(EPOCBLD$Bld)\"\n",
-		"\t$Archive -M < <<\n",
-		"CREATE \$(\@F)\n",
-		"ADDMOD \$(**F)\n",
-		"SAVE\n",
-		"END\n",
-		"<<\n",
-		"\tcd \"\$(MAKEDIR)\"\n",	# cd back to the directory where NMAKE was invoked
+		"\$(EPOCBLD$Bld)/$BaseTrg.in : \$(OBJECTS",$Bld,")\n",
+		"\t$Archive rcs \$\@ \$(OBJECTS",$Bld,")\n",
 		"\n\n"
 	);
+
 }
 
 
@@ -1087,21 +1090,22 @@ sub PMBitMapBld {
 
 	my $BitMapHdr=join('', &main::EPOCIncPath, &main::Path_Split('Base', $$BitMapRef{Trg}), '.mbg');
 	my $RTWBitMapHdr=&main::Path_RltToWork($BitMapHdr);
-	my $TmpBitMapHdr=join('', &main::BldPath, &main::Path_Split('Base', $$BitMapRef{Trg}), '.mbg');
-	my $RTWTmpBitMapHdr=&main::Path_RltToWork($TmpBitMapHdr);
+	my $TmpBitMapHdr=join('', &main::Path_Split('Base', $$BitMapRef{Trg}), '.mbg');
 
 	&main::Output(
-		"\"\$(EPOCTRG$Bld)\\$$BitMapRef{Trg}\" :"
+		"\$(EPOCTRG$Bld)\/$$BitMapRef{Trg} :"
 	);
 	my $SrcRef;
 	foreach $SrcRef (@{$$BitMapRef{Source}}) {
 		&main::Output(
-			" \"$$SrcRef{Src}\""
+			" $$SrcRef{Src}"
 		);
 	}
+
+	# set bmconv program
 	&main::Output(
 		"\n",
-		"\tbmconv <<\n",
+		"\tbmconv ",
 		" /q"
 	);
 	if ($$BitMapRef{Hdr}) {
@@ -1110,24 +1114,19 @@ sub PMBitMapBld {
 		);
 	}
 	&main::Output(
-		" \$(EPOCTRG$Bld)\\$$BitMapRef{Trg}\n"
+		" /.\$(EPOCTRG$Bld)\/$$BitMapRef{Trg}"
 	);
 	foreach $SrcRef (@{$$BitMapRef{Source}}) {
 		&main::Output(
-			" /$$SrcRef{ClDepth}$$SrcRef{Src}\n"
+			" \\\n\t/$$SrcRef{ClDepth}$$SrcRef{Src}"
 		);
 	}
 	&main::Output(
-		"<<\n"
+		"\n"
 	);
 	if ($$BitMapRef{Hdr}) {
 		&main::Output(
-			"\tcall <<\"MayRewriteHdr.bat\"\n",
-			"\t\@echo off\n",
-			"\tdiff \"$RTWTmpBitMapHdr\" \"$RTWBitMapHdr\" >NUL\n",
-			"\tif errorlevel==1 copy \"$TmpBitMapHdr\" \"$BitMapHdr\"\n",
-			"<<\n",
-			"\tdel \"$TmpBitMapHdr\"\n",
+			"\tmv -f $TmpBitMapHdr $BitMapHdr\n"
 		);
 	}
 	&main::Output(
@@ -1162,7 +1161,7 @@ sub PMResrcDepend {
 	foreach (@DepList) {
 		&main::Output(
 			" \\\n",
-			"\t\"$_\""
+			"\t$_"
 		);
 	}
 	&main::Output(
@@ -1180,21 +1179,18 @@ sub PMResrcBld {
 	my $RTWSrcPath=&main::Path_RltToWork($SrcPath);
 	my $ChopRTWSrcPath=&main::Path_Chop($RTWSrcPath);
 
-	my $ResrcHdr=join '', &main::EPOCIncPath(), $BaseResrc, '.RSG';
+	my $ResrcHdr=join '', &main::EPOCIncPath(), $BaseResrc, '.rsg';
 	my $RTWResrcHdr=&main::Path_RltToWork($ResrcHdr);
 
 	my $Lang;
 	foreach $Lang (@LangList) {
 		&main::Output(
-			"\"\$(EPOCTRG$Bld)\\$BaseResrc.R$Lang\": \"$SrcPath$Resrc\" \$(DEPEND)\n",
-			"\tperl -S epocrc.pl -I \"$ChopRTWSrcPath\" \$(INCDIR) -DLANGUAGE_$Lang -u \"$RTWSrcPath$Resrc\" ",
-			"-o\$\@ -h\"$RTWSrcPath$BaseResrc.rs~\" -t\"\$(EPOCBLD$Bld)\"\n",
-			"\tcall <<\"MayRewriteHdr.bat\"\n",
-			"\t\@echo off\n",
-			"\tdiff \"$RTWSrcPath$BaseResrc.rs~\" \"$RTWResrcHdr\" >NUL\n",
-			"\tif errorlevel==1 copy \"$RTWSrcPath$BaseResrc.rs~\" \"$ResrcHdr\"\n",
-			"<<\n",
-			"\tdel \"$RTWSrcPath$BaseResrc.rs~\"\n",
+			"\$(EPOCTRG$Bld)\/$BaseResrc.r$Lang: $SrcPath$Resrc \$(DEPEND)\n",
+			"\techo \"$BaseResrc.r$Lang\"\n",
+			"\tperl -S epocrc.pl -I $ChopRTWSrcPath \$(INCDIR) -D__SERIES60__ -DLANGUAGE_$Lang -u $RTWSrcPath$Resrc ",
+			"-o\$\@ -h$RTWSrcPath$BaseResrc.rs~ -t\$(EPOCBLD$Bld)\n",
+			"\tcp -f $RTWSrcPath$BaseResrc.rs~ $ResrcHdr\n",
+			"\trm -f $RTWSrcPath$BaseResrc.rs~\n",
 			"\n"
 		);
 	}
@@ -1227,7 +1223,7 @@ sub PMAifDepend {
 	foreach (@DepList) {
 		&main::Output(
 			" \\\n",
-			"\t\"$_\""
+			"\t$_"
 		);
 	}
 	&main::Output(
@@ -1239,30 +1235,30 @@ sub PMAifDepend {
 sub PMAifBld {
 	my $AifRef=&main::AifRef;
 	my $Bld=&main::Bld;
-	my @ChopRTWSysIncPaths=&main::Path_Chop(&main::Path_RltToWork(&main::SysIncPaths));
-	my @ChopRTWUserIncPaths=&main::Path_Chop(&main::Path_RltToWork(&main::UserIncPaths));
+	my @ChopRTWSysIncPaths=&main::Path_Chop(&main::SysIncPaths);
+	my @ChopRTWUserIncPaths=&main::Path_Chop(&main::UserIncPaths);
 
 	my $BaseResrc=&main::Path_Split('Base',$$AifRef{Resrc});
-	my $ChopRTWAifDir=&main::Path_Chop(&main::Path_RltToWork($$AifRef{Dir}));
+	my $ChopRTWAifDir=$$AifRef{Dir};
 	my $ChopBldPath=&main::Path_Chop(&main::BldPath);
 
 	&main::Output(
-		"\"\$(EPOCTRG$Bld)\\$$AifRef{Trg}\" : \"$$AifRef{Dir}$$AifRef{Resrc}\" \$(DEPEND)"
+		"\$(EPOCTRG$Bld)\/$$AifRef{Trg}: $$AifRef{Dir}$$AifRef{Resrc} \$(DEPEND)"
 	);
 	if (@{$$AifRef{BitMaps}}) { # bitmaps aren't essential
 		my $BitMap;
 		foreach $BitMap (@{$$AifRef{BitMaps}}) {
 			&main::Output(
-				" \"$$AifRef{Dir}$BitMap\""
+				" $$AifRef{Dir}$BitMap"
 			);
 		}
 	}
 	&main::Output(
 		"\n",
 		"\tperl -S epocaif.pl -o\$@ ",
-		"\"$ChopRTWAifDir\\$$AifRef{Resrc}\" ",
+		"\"$ChopRTWAifDir\/$$AifRef{Resrc}\" ",
 		"\\\n\t\t",
-		"-t\"$ChopBldPath\" ",
+		"-t. ",
 		"\\\n\t\t"
 	);
 	if (@{$$AifRef{BitMaps}}) { 
@@ -1281,7 +1277,7 @@ sub PMAifBld {
 	}
 	foreach (@ChopRTWUserIncPaths) {
 		&main::Output(
-			" -I \"$_\""
+			" -I $_"
 		);
 	}
 	&main::Output(
@@ -1289,11 +1285,10 @@ sub PMAifBld {
 	);
 	foreach (@ChopRTWSysIncPaths) {
 		&main::Output(
-			" -I \"$_\""
+			" -I $_"
 		);
 	}
 	&main::Output(
-		"\n",
 		"\n"
 	);
 }
@@ -1324,7 +1319,7 @@ sub PMSrcDepend {
 	);
 	foreach (@DepList) {
 		&main::Output(
-		" \\\n\t\"$_\""
+		" \\\n\t$_"
 		);
 	}
 	&main::Output(
@@ -1351,7 +1346,7 @@ sub PMSrcBldDepend {
 	);
 	foreach (@DepList) {
 		&main::Output(
-			" \\\n\t\"$_\""
+			" \\\n\t$_"
 		);
 	}
 	&main::Output(
@@ -1363,24 +1358,42 @@ sub PMSrcBldDepend {
 sub PMEndSrcBld {
 	my $BaseSrc=&main::BaseSrc;
 	my $Bld=&main::Bld;
-	my $Src=ucfirst lc &main::Src;
+	my $Src=&main::Src;
 	my $SrcPath=&main::SrcPath;
 
-	my $RTWSrcPath=&main::Path_RltToWork($SrcPath);
+	my $tmp = lc $Bld;
 
 	# Use GCC trick to get assembler source files preprocessed with CPP
 	$Src =~ s/\.s$/.S/i;
 
 	&main::Output(
-		"\"\$(EPOCBLD$Bld)\\$BaseSrc.o\": \"$SrcPath$Src\" \$(DEPEND$Bld)\n",
-		"\t\$(GCC$Bld) -I \"$RTWSrcPath\" \$(INCDIR) -o \$\@ \"$RTWSrcPath$Src\"\n",
+		"\$(EPOCBLD$Bld)\/$BaseSrc.o: $SrcPath$Src \$(DEPEND$Bld)\n",
+		"\techo \"$BaseSrc.o\"\n",
+	);
+
+	#
+	# PVM - Paralell Virtual Machine
+	#
+	# if the environment variable PVM_ROOT is defined, it probably means that
+	# PVM is installed on the system. add printing of hostname to makefile for
+	# debugging purposes.
+	#
+	if($ENV{PVM_ROOT}) {
+	  print "adding HOSTNAME to makefile (for PVM)\n";
+	  &main::Output(
+			"\t\@echo \"HOSTNAME: `hostname`\"\n",
+		       );
+	}
+
+	&main::Output(
+		"\t\$(GCC$Bld) -I $SrcPath \$(INCDIR) -o \$\@ $SrcPath$Src\n",
 		"\n",
 #		generate an assembly listing target too
-		"LISTING$Bld$BaseSrc : MAKEWORKBUILD$Bld \"\$(EPOCBLD$Bld)\\$BaseSrc.lis\"\n",
+		"listing$Bld$BaseSrc: makeworkbuild$tmp \$(EPOCBLD$Bld)\/$BaseSrc.lis\n",
 		"\n",
-		"\"\$(EPOCBLD$Bld)\\$BaseSrc.lis\": \"$SrcPath$Src\" \$(DEPEND$Bld)\n",
-		"\t\$(GCC$Bld) -Wa,-adln -I \"$RTWSrcPath\" \$(INCDIR) -o nul: \"$RTWSrcPath$Src\" > \$\@\n",
-		"\tcopy \$\@ \"$SrcPath$BaseSrc.lis\"\n",
+		"\$(EPOCBLD$Bld)\/$BaseSrc.lis: $SrcPath$Src \$(DEPEND$Bld)\n",
+		"\t\$(GCC$Bld) -Wa,-adln -I $SrcPath \$(INCDIR) -o nul: $SrcPath$Src > \$\@\n",
+		"\tcp \$\@ $SrcPath$BaseSrc.lis\n",
 		"\n"
 	);
 }
diff --git a/cl_win.pm b/cl_win.pm
index dd81df8..f5828ca 100644
--- a/cl_win.pm
+++ b/cl_win.pm
@@ -2,9 +2,11 @@
 #
 # Copyright (c) 1997-1999 Symbian Ltd.  All rights reserved.
 #
+# modified by GnuPoc ER6 to generate GNU Make makefiles instead of
+# NMake makefiles - CL.EXE and LINK.EXE ++ runs under WINE
+#
 
-
-package Cl_win;
+package cl_win;
 
 # declare variables global for module
 my @Win32LibList=();
@@ -42,7 +44,7 @@ require Exporter;
 	PMEndSrcList
 );
 
-use Winutl;
+use winutl;
 
 sub PMHelp_Mmp {
 	&Winutl_Help_Mmp;
@@ -89,6 +91,10 @@ sub PMStartBldList {
 
 
 	&main::Output(
+		"#\n",
+		"#   this makefile is for GNU make\n",
+		"#   generated by GnuPoc - EPOC SDK for GNU/Linux\n",
+		"#\n",
 		"\n",
 		'# CWD ', &main::Path_WorkPath, "\n",
 		'# MMPFile ', &main::MmpFile, "\n",
@@ -96,13 +102,7 @@ sub PMStartBldList {
 		"# TargetType $TrgType\n",
 		"# BasicTargetType $BasicTrgType\n",
 		"\n",
-		"\n",
-		"!if \"\$(OS)\" == \"Windows_NT\"\n",
-		"ERASE = \@erase 2>>nul\n",
-		"!else\n",
-		"ERASE = \@erase\n",
-		"!endif\n",
-		"\n",
+		"ERASE = rm -Rf\n",
 		"\n",
 		"# EPOC DEFINITIONS\n",
 		"\n"
@@ -113,7 +113,7 @@ sub PMStartBldList {
 	);
 	foreach (@ChopUserIncPaths,@ChopSysIncPaths) {
 		&main::Output(
-			" /I \"$_\""
+			" /I $_"
 		);
 	}
 	&main::Output(
@@ -122,7 +122,7 @@ sub PMStartBldList {
 	);
 
 	&main::Output(
-		"CLFLAGS = /nologo /Zp4 /W4"
+		"CLFLAGS = /nologo /Zp4 /W4 /QIfist"
 	);
 # tools hack in line below
 	unless (@Win32LibList or &main::Plat eq 'TOOLS') {
@@ -139,8 +139,9 @@ sub PMStartBldList {
 		"CLDEFS  ="
 	);
 	foreach(@MacroList) {
+	        my $tmp = uc $_;
 		&main::Output(
-			" /D \"$_\""
+			" /D $tmp"
 		);
 	}
 	&main::Output(
@@ -149,20 +150,21 @@ sub PMStartBldList {
 	);
 
 	&main::Output(
-		"EPOCBLD = $BldPath #\n",
-		"EPOCTRG = $RelPath #\n",
-		"EPOCLIB = $LibPath #\n",
-		"EPOCLINK = $LinkPath #\n",
-		"EPOCSTATLINK = $StatLinkPath #\n",
+		"EPOCBLD = $BldPath\n",
+		"EPOCTRG = $RelPath\n",
+		"EPOCLIB = $LibPath\n",
+		"EPOCLINK = $LinkPath\n",
+		"EPOCSTATLINK = $StatLinkPath\n",
 		"\n"
 	);
 	foreach (@BldList) {
+	        my $tmp = lc $_;
 		&main::Output(
-			"EPOCBLD$_ = \$(EPOCBLD)$_\n",
-			"EPOCTRG$_ = \$(EPOCTRG)$_\n",
-			"EPOCLIB$_ = \$(EPOCLIB)UDEB\n",
-			"EPOCLINK$_ = \$(EPOCLINK)UDEB\n",
-			"EPOCSTATLINK$_ = \$(EPOCSTATLINK)$_\n",
+			"EPOCBLD$_ = \$(EPOCBLD)$tmp\n",
+			"EPOCTRG$_ = \$(EPOCTRG)$tmp\n",
+			"EPOCLIB$_ = \$(EPOCLIB)udeb\n",
+			"EPOCLINK$_ = \$(EPOCLINK)udeb\n",
+			"EPOCSTATLINK$_ = \$(EPOCSTATLINK)$tmp\n",
 			"\n"
 		);
 	}
@@ -180,7 +182,7 @@ sub PMStartBldList {
 	}
 	else {
 		&main::Output(
-			".\\"
+			".\/" # TODO check
 		);
 	}
 	&main::Output(
@@ -194,7 +196,7 @@ sub PMStartBldList {
 	);
 	foreach (@BldList) {
 		&main::Output(
-			"CL$_ = cl.exe"
+			"CL$_ = wine CL.EXE"
 		);
 		if ($BasicTrgType=~/^EXE$/o) {
 			&main::Output(
@@ -240,12 +242,13 @@ sub PMStartBldList {
 		);
 		if (/DEB$/o) {
 			&main::Output(
-				" /FR\"\$(EPOCBLD$_)/\" /Fd\"\$(EPOCTRG$_)\\\$(TRGDIR)\\$BaseTrg.pdb\""
+				" /FR\$(EPOCBLD$_)/ /Fd\$(EPOCTRG$_)\/\$(TRGDIR)\/$BaseTrg.pdb"
 			);
 		}
 		foreach (&main::MacroList($_)) {
+		        my $tmp = uc $_;
 			&main::Output(
-				" /D $_"
+				" /D $tmp"
 			);
 		}
 		&main::Output(
@@ -263,23 +266,24 @@ sub PMStartBldList {
 		"\n"
 	);
 	foreach (@BldList) {
+	        my $tmp = lc $_;
 		&main::Output(
-			"$_ :"
+			"$tmp :"
 		);
 
 		&main::Output(
 			" \\\n",
-			"\tRESOURCE$_"
+			"\tresource$tmp"
 		);
 
 		&main::Output (
 			" \\\n",
-			"\t\"\$(EPOCTRG$_)\\\$(TRGDIR)\\$Trg\""
+			"\t\$(EPOCTRG$_)\/\$(TRGDIR)\/$Trg"
 		);
 		unless (/REL$/o) {
 			&main::Output(
 				" \\\n",
-				"\t\"\$(EPOCTRG$_)\\$BaseTrg.bsc\""
+				"\t\$(EPOCTRG$_)\/$BaseTrg.bsc"
 			);
 		}
 
@@ -287,7 +291,7 @@ sub PMStartBldList {
 		if ($DefFile and not &main::ExportUnfrozen) {
 			&main::Output(
 				" \\\n",
-				"\tLIBRARY\n"
+				"\tlibrary\n"
 			);
 		}
 		&main::Output(
@@ -298,86 +302,94 @@ sub PMStartBldList {
 
 
 	&main::Output(	# ALL comes after DEB: because first target in makefile is the default
-		"ALL :"
+		"all ALL :"
 	);
 	foreach (@BldList) {
+		my $tmp = lc $_;
 		&main::Output(
-			" $_"
+			" $tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"WHAT WHATALL :"
+		"what whatall :"
 	);
 	foreach (@BldList) {
+		my $tmp = lc $_;
 		&main::Output(
-			" WHAT$_"
+			" what$tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"RESOURCE RESOURCEALL :"
+		"resource resourceall :"
 	);
 	foreach (@BldList) {
+		my $tmp = lc $_;
 		&main::Output(
-			" RESOURCE$_"
+			" resource$tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"CLEAN CLEANALL : CLEANBUILD CLEANRELEASE CLEANLIBRARY",
+		"clean cleanall : cleanbuild cleanrelease cleanlibrary",
 		"\n",
 		"\n",
-		"CLEANBUILD CLEANBUILDALL :"
+		"cleanbuild cleanbuildall:"
 	);
 	foreach (@BldList) {
+		my $tmp = lc $_;
 		&main::Output(
-			" CLEANBUILD$_"
+			" cleanbuild$tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"CLEANRELEASE :"
+		"cleanrelease :"
 	);
 	foreach (@BldList) {
+		my $tmp = lc $_;
 		&main::Output(
-			" CLEANRELEASE$_"
+			" cleanrelease$tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"MAKEWORK : MAKEWORKBUILD MAKEWORKRELEASE MAKEWORKLIBRARY\n",
+		"makework : makeworkbuild makeworkrelease makeworklibrary\n",
 		"\n",
-		"MAKEWORKBUILD :"
+		"makeworkbuild :"
 	);
 	foreach (@BldList) {
+		my $tmp = lc $_;
 		&main::Output(
-			" MAKEWORKBUILD$_"
+			" makeworkbuild$tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"MAKEWORKRELEASE :"
+		"makeworkrelease :"
 	);
 	foreach (@BldList) {
+	        my $tmp = lc $_;
 		&main::Output(
-			" MAKEWORKRELEASE$_"
+			" makeworkrelease$tmp"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"LISTING :"
+		"listing:"
 	);
 	foreach (@BldList) {
+		my $tmp = lc $_;
 		&main::Output(
-			" LISTING$_"
+			" listing$tmp"
 		);
 	}
 	&main::Output(
@@ -387,16 +399,17 @@ sub PMStartBldList {
 
 
 	foreach (@BldList) {
+	        my $tmp = lc $_;
 		&main::Output(
 			"\n",
-			"RESOURCE$_ : MAKEWORK$_"
+			"resource$tmp: makework$tmp"
 		);
 
 		my $BitMapRef;
 		foreach $BitMapRef (@$BitMapStructRef) {
 			&main::Output(
 				" \\\n",
-				"\t\"\$(EPOCTRG$_)\\"
+				"\t\$(EPOCTRG$_)\/"
 			);
 			if ($$BitMapRef{TrgPath}) {
 				&main::Output(
@@ -404,7 +417,7 @@ sub PMStartBldList {
 				);
 			}
 			&main::Output(
-				"$$BitMapRef{Trg}\""
+				"$$BitMapRef{Trg}"
 			);
 		}
 		undef $BitMapRef;
@@ -415,7 +428,7 @@ sub PMStartBldList {
 			foreach $Lang (@LangList) {
 				&main::Output(	# must come before main target because source for target will depend on the
 				" \\\n",						# *.rsg file in $EPOCIncPath
-				"\t\"\$(EPOCTRG$_)\\\$(DATADIR)\\$BaseResrc.R$Lang\""
+				"\t\$(EPOCTRG$_)\/\$(DATADIR)\/$BaseResrc.r$Lang"
 				);
 			}
 		}
@@ -424,7 +437,7 @@ sub PMStartBldList {
 			foreach $Lang (@LangList) {
 				&main::Output(	# must come before main target because source for target will depend on the
 				" \\\n",						# *.rsg file in $EPOCIncPath
-				"\t\"\$(EPOCTRG$_)\\\$(TRGDIR)\\$BaseResrc.R$Lang\""
+				"\t\$(EPOCTRG$_)\/\$(TRGDIR)\/$BaseResrc.r$Lang"
 				);
 			}
 		}
@@ -434,7 +447,7 @@ sub PMStartBldList {
 		foreach $AifRef (@$AifStructRef) {
 			&main::Output(
 				" \\\n",
-				"\t\"\$(EPOCTRG$_)\\\$(TRGDIR)\\$$AifRef{Trg}\""
+				"\t\$(EPOCTRG$_)\/\$(TRGDIR)\/$$AifRef{Trg}"
 			);
 		}
 		undef $AifRef;
@@ -449,13 +462,14 @@ sub PMStartBldList {
 	);
 
 	&main::Output(
-		"LIBRARY :"
+		"library:"
 	);
 	if ($BasicTrgType=~/^LIB$/o) {
 #		code to ensure that the static libraries for all builds are built at the library stage
 		foreach (@BldList) {
+			my $tmp = lc $_;
 			&main::Output(
-				" $_"
+				" $tmp"
 			);
 		}
 	}
@@ -463,13 +477,13 @@ sub PMStartBldList {
 		unless (&main::ExportUnfrozen) {
 			if (-e $DefFile) { # effectively "if project frozen ..."
 				&main::Output(
-					" \"\$(EPOCLIB)UDEB\\$BaseTrg.LIB\"\n"
+					" \$(EPOCLIB)udeb\/$BaseTrg.lib\n"
 				);
 			}
 			else {
 				&main::Output(
 					"\n",
-					"\t\@echo WARNING: Not attempting to create \"\$(EPOCLIB)UDEB\\$BaseTrg.LIB\".\n",
+					"\t\@echo WARNING: Not attempting to create \"\$(EPOCLIB)udeb\/$BaseTrg.lib\".\n",
 					"\t\@echo When exports are frozen in \"$DefFile\", regenerate Makefile.\n"
 				);
 			}
@@ -477,8 +491,8 @@ sub PMStartBldList {
 		else {
 			&main::Output(
 				"\n",
-				"\t\@echo Not attempting to create \"\$(EPOCLIB)UDEB\\$BaseTrg.LIB\"\n",
-				"\t\@echo from frozen .DEF file, since EXPORTUNFROZEN specified.\n"
+				"\t\@echo Not attempting to create \"\$(EPOCLIB)udeb\/$BaseTrg.lib\"\n",
+				"\t\@echo from frozen .DEF file, since EXPORTFROZEN specified.\n"
 			);
 		}
 		&main::Output(
@@ -486,37 +500,37 @@ sub PMStartBldList {
 			"\n",
 			"# REAL TARGET - LIBRARY\n",
 			"\n",
-			"\"\$(EPOCLIB)UDEB\\$BaseTrg.LIB\" : \"$DefFile\" MAKEWORKLIBRARY\n",
-			"\tlib.exe /nologo /machine:i386 /nodefaultlib /name:\"$Trg\" /def:\"$DefFile\" /out:\"\$(EPOCLIB)UDEB\\$BaseTrg.LIB\"\n",
-			"\tdel \"\$(EPOCLIB)UDEB\\$BaseTrg.exp\"\n"
+			"\$(EPOCLIB)udeb\/$BaseTrg.lib : $DefFile makeworklibrary\n",
+			"\twine LIB.EXE /nologo /machine:i386 /nodefaultlib /name:\"$Trg\" /def:\"$DefFile\" /out:\"\$(EPOCLIB)udeb\/$BaseTrg.lib\"\n",
+			"\trm -f \$(EPOCLIB)udeb\/$BaseTrg.exp\n"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n",
-		"FREEZE :\n"
+		"freeze:\n"
 	);
 	if ($DefFile) {
 		&main::Output(
-#			call perl on the script here so nmake will die if there are errors - this doesn't happen if calling perl in a batch file
+#			call perl on the script here so make will die if there are errors - this doesn't happen if calling perl in a batch file
 			"\tperl -S efreeze.pl \"$DefFile\" \"\$(EPOCBLD)$BaseTrg.def\" \n"
 		);
 	}
 	&main::Output(
 		"\n",
-		"CLEANLIBRARY :\n"
+		"cleanlibrary:\n"
 	);
 	if ($DefFile) {
 		&main::Output(
-			"\t-\$(ERASE) \"\$(EPOCLIB)UDEB\\$BaseTrg.*\"\n"
+			"\t-\$(ERASE) \$(EPOCLIB)udeb\/$BaseTrg.*\n"
 		);
 	}
 	&main::Output(
 		"\n",
-		"MAKEWORKLIBRARY : \"${LibPath}UDEB\"\n",
+		"makeworklibrary : ${LibPath}udeb\n",
 		"\n",
-		"\"${LibPath}UDEB\" :\n",
-		"\t\@perl -S emkdir.pl \"${LibPath}UDEB\"\n",
+		"${LibPath}udeb:\n",
+		"\t\@mkdir -p ${LibPath}udeb\n",
 		"\n",
 		"\n"
 	);
@@ -531,15 +545,16 @@ sub PMBld {
 	my $BaseTrg=&main::BaseTrg;
 	my $BitMapStructRef=&main::BitMapStructRef;
 	my $Bld=&main::Bld;
+	my $Bld2=lc &main::Bld;
 	my $ChopBldPath=&main::Path_Chop(&main::BldPath);
 	my $ChopDataPath=&main::Path_Chop(&main::DataPath);
 	my $DefFile=&main::DefFile;
 	my $EPOCIncPath=&main::EPOCIncPath;
-	my $EPOCLocPath=&main::EPOCPath."Localisation\\";
+	my $EPOCLocPath=&main::EPOCPath."Localisation/";
 	my $FirstLib=&main::FirstLib;
 	my $BasicTrgType=&main::BasicTrgType;
 	my @LangList=&main::LangList;
-	my @LibList;
+	my @LibList=&main::LibList;
 	my $RelPath=&main::RelPath;
 	my @StatLibList=&main::StatLibList;
 	my $Trg=&main::Trg;
@@ -562,9 +577,10 @@ sub PMBld {
 		@LibList=&main::LibList;
 	}
 
-	my $BLDTRGPATH = "\$(EPOCTRG$Bld)\\";
+
+	my $BLDTRGPATH = "\$(EPOCTRG$Bld)/";
 	if ($TrgPath) {
-		$BLDTRGPATH .= "\$(TRGDIR)\\";	    # handles TARGETPATH
+		$BLDTRGPATH .= "\$(TRGDIR)/";      # handles TARGETPATH
 	}
 
 	# REAL TARGETS
@@ -576,17 +592,25 @@ sub PMBld {
 
 #	releasables
 	&main::Output(
-		"RELEASEABLES=",
+		"what$Bld2 : "
 	);
 #tools hack
 	unless (&main::Plat() eq 'TOOLS') {
 		&main::Output(
-			" \\\n\t\"$BLDTRGPATH$Trg\""
+			" \\\n\t\@echo \$(EPOCTRG$Bld)\/"
+		);
+		if ($TrgPath) {
+			&main::Output(
+				"\$(TRGDIR)\/"
+			);
+		}
+		&main::Output(
+			"$Trg"
 		);
 		my $BitMapRef;
 		foreach $BitMapRef (@$BitMapStructRef) {
 			&main::Output(
-				" \\\n\t\"\$(EPOCTRG$Bld)\\"
+				" \\\n\t\@echo \$(EPOCTRG$Bld)\/"
 			);
 			if ($$BitMapRef{TrgPath}) {
 				&main::Output(
@@ -594,11 +618,11 @@ sub PMBld {
 				);
 			}
 			&main::Output(
-				"$$BitMapRef{Trg}\""
+				"$$BitMapRef{Trg}"
 			);
 			if ($$BitMapRef{Hdr}) {
 				&main::Output(
-					" \\\n\t\"$EPOCIncPath", &main::Path_Split('Base', $$BitMapRef{Trg}), ".MBG\""
+					" \\\n\t\@echo $EPOCIncPath", &main::Path_Split('Base', $$BitMapRef{Trg}), ".mbg"
 				);
 			}
 		}
@@ -607,46 +631,46 @@ sub PMBld {
 			my $Lang;
 			foreach $Lang (@LangList) {
 				&main::Output(
-					" \\\n\t\"\$(EPOCTRG$Bld)\\\$(DATADIR)\\$BaseResrc.R$Lang\""
+					" \\\n\t\$(EPOCTRG$Bld)\\\$(DATADIR)\\$BaseResrc.r$Lang"
 				);
 			}
 			&main::Output(
-				" \\\n\t\"$EPOCLocPath$BaseResrc.rpp\"",
-				" \\\n\t\"$EPOCIncPath$BaseResrc.RSG\""
+				" \\\n\t$EPOCLocPath$BaseResrc.rpp",
+				" \\\n\t$EPOCIncPath$BaseResrc.rsg"
 			);
 		}
 		foreach $BaseResrc (@BaseResrcList) {
 			my $Lang;
 			foreach $Lang (@LangList) {
 				&main::Output(
-					" \\\n\t\"$BLDTRGPATH$BaseResrc.R$Lang\""
+					" \\\n\t$BLDTRGPATH$BaseResrc.r$Lang"
 				);
 			}
 			&main::Output(
-				" \\\n\t\"$EPOCLocPath$BaseResrc.rpp\"",
-				" \\\n\t\"$EPOCIncPath$BaseResrc.RSG\""
+				" \\\n\t$EPOCLocPath$BaseResrc.rpp",
+				" \\\n\t$EPOCIncPath$BaseResrc.rsg"
 			);
 		}
 		my $AifRef;
 		foreach $AifRef (@$AifStructRef) {
 			&main::Output(
-				" \\\n\t\"$BLDTRGPATH$$AifRef{Trg}\""
+				" \\\n\t$BLDTRGPATH$$AifRef{Trg}"
 			);
 		}
 		if (-e $DefFile) { # effectively "if project frozen ..."
 			&main::Output(
-				" \\\n\t\"\$(EPOCLIB$Bld)\\$BaseTrg.LIB\""
+				" \\\n\t\$(EPOCLIB$Bld)/$BaseTrg.lib"
 			);
 		}
 		if ($Bld=~/DEB$/o) {
 			&main::Output(
-				" \\\n\t\"$BLDTRGPATH$BaseTrg.PDB\""
+				" \\\n\t$BLDTRGPATH$BaseTrg.pdb"
 			);
 		}
 	}
 	else {
 		&main::Output(
-			" \\\n\t\"", &main::EPOCToolsPath(), "$Trg\""
+			" \\\n\t", &main::EPOCToolsPath(), "$Trg"
 		);
 	}
 #tools hack end
@@ -656,31 +680,73 @@ sub PMBld {
 	);
 
 	&main::Output(
-		"WHAT$Bld :\n",
-		"\t\@echo \$(RELEASEABLES)\n",
+		"clean$Bld2 : cleanbuild$Bld2 cleanrelease$Bld2\n",
 		"\n",
-		"CLEAN$Bld : CLEANBUILD$Bld CLEANRELEASE$Bld\n",
+		"cleanbuild$Bld2 : \n",
+		"\t\@rm -Rf \$(EPOCBLD$Bld)\n",
+		"\t-\$(ERASE) \$(EPOCTRG$Bld)\/\$(TRGDIR)\/$BaseTrg.ilk\n",
 		"\n",
-		"CLEANBUILD$Bld : \n",
-		"\t\@perl -S ermdir.pl \"\$(EPOCBLD$Bld)\"\n",
-		"\t-\$(ERASE) \"$BLDTRGPATH$BaseTrg.ILK\"\n",
+		"cleanrelease$Bld2 : \n",
+		"\t-\$(ERASE) \$(EPOCTRG$Bld)\/\$(TRGDIR)\/$BaseTrg.*\n",
+		"\t-\$(ERASE) \$(EPOCTRG$Bld)\/$BaseTrg.*\n"
+	);
+# tools hack
+	if (&main::Plat eq 'TOOLS') {
+		&main::Output(
+			"\t-\$(ERASE) \"",&main::EPOCToolsPath,"$Trg\"\n"
+		);
+	}
+# tools hack end
+	foreach (@$BitMapStructRef) {
+		&main::Output(
+			"\t-\$(ERASE) \$(EPOCTRG$Bld)\/"
+		);
+		if ($$_{TrgPath}) {
+			&main::Output(
+				$$_{TrgPath}
+			);
+		}
+		&main::Output(
+			"$$_{Trg}\n"
+		);
+		if ($$_{Hdr}) {
+			&main::Output(
+				 "\t-\$(ERASE) $EPOCIncPath", &main::Path_Split('Base', $$_{Trg}),".mbg\n"
+			);
+		}
+	}
+	foreach (@BaseSysResrcList) {
+		&main::Output(
+			"\t-\$(ERASE) \$(EPOCTRG$Bld)\/\$(DATADIR)\/$_.r*\n",
+			"\t-\$(ERASE) $EPOCIncPath$_.rsg\n"
+		);
+	}
+	foreach (@BaseResrcList) {
+		&main::Output(
+			"\t-\$(ERASE) \$(EPOCTRG$Bld)\/\$(TRGDIR)\/$_.r*\n",
+			"\t-\$(ERASE) $EPOCIncPath$_.rsg\n"
+		);
+	}
+	foreach (@$AifStructRef) {
+		&main::Output(
+			"\t-\$(ERASE) \$(EPOCTRG$Bld)\/\$(TRGDIR)\/$$_{Trg}\n"
+		);
+	}
+	&main::Output(
 		"\n",
-		"CLEANRELEASE$Bld : \n",
-		"\t-\$(ERASE) \$(RELEASEABLES)\n",
-		"\t-\$(ERASE) \"$BLDTRGPATH$BaseTrg.ILK\"\n",
 		"\n"
 	);
 
 	&main::Output(
-		"MAKEWORK$Bld : MAKEWORKBUILD$Bld MAKEWORKRELEASE$Bld\n",
+		"makework$Bld2: makeworkbuild$Bld2 makeworkrelease$Bld2\n",
 		"\n",
-		"MAKEWORKBUILD$Bld : \"$ChopBldPath\"\n",
+		"makeworkbuild$Bld2: $ChopBldPath\n",
 		"\n",
-		"MAKEWORKRELEASE$Bld : \"$RelPath$ChopTrgPath\""
+		"makeworkrelease$Bld2: $RelPath$ChopTrgPath"
 	);
 	if (@BaseSysResrcList) {
 		&main::Output(
-			" \"$RelPath$ChopDataPath\""
+			" $RelPath$ChopDataPath"
 		);
 	}
 	&main::Output(
@@ -689,8 +755,8 @@ sub PMBld {
 	);
 	foreach ($ChopBldPath, "$RelPath$ChopTrgPath", "$RelPath$ChopDataPath") {
 		&main::Output(
-			"\"$_\" : \n",
-			"\t\@perl -S emkdir.pl \"$_\"\n",
+			"$_ : \n",
+			"\t\@mkdir -p \"$_\"\n",
 			"\n"
 		);
 	}
@@ -699,11 +765,11 @@ sub PMBld {
 	);
 
 	&main::Output(
-		"LISTING$Bld :"
+		"listing$Bld2 :"
 	);
 	foreach (@BaseSrcList) {
 		&main::Output(
-			" \\\n\tLISTING$Bld$_"
+			" listing$Bld2$_"
 		);
 	}
 	&main::Output(
@@ -718,52 +784,97 @@ sub PMBld {
 		foreach (@BaseSrcList) {
 			&main::Output(
 				" \\\n",
-				"\t\"\$(EPOCBLD$Bld)\\$_.sbr\""
+				"\t\$(EPOCBLD$Bld)\/$_.sbr"
 			);
 		}
 		&main::Output(
 			"\n",
 			"\n",
-		"\"\$(EPOCTRG$Bld)\\$BaseTrg.bsc\" : \$(BSC32_SBRS)\n",
-		"\tbscmake.exe \@<<\n",
+		"\$(EPOCTRG$Bld)\/$BaseTrg.bsc : \$(BSC32_SBRS)\n",
+		"\twine bscmake.exe \\\n",
 		"\t/nologo /o\$\@ \$(BSC32_SBRS)\n",
-		"<<\n",
+#		"<<\n",
 		"\n",
 		"\n"
 		);
 	}
 
 	&main::Output(
-		"LIBS="
+		"LIBS_",$Bld,"="
+	);
+	foreach (@StatLibList) {
+		&main::Output(
+			" \\\n\t\$(EPOCSTATLINK$Bld)\/$_"
+		);
+	}
+	foreach (@LibList) {
+		&main::Output(
+			" \\\n\t\$(EPOCLINK$Bld)\/$_"
+		);
+	}
+	&main::Output(
+		"\n",
+		"\n"
+	);
+
+#
+# extra lib defs to satisfy wine
+#
+	&main::Output(
+		"LIBS_",$Bld,"_WIN="
 	);
 	foreach (@StatLibList) {
 		&main::Output(
-			" \\\n\t\"\$(EPOCSTATLINK$Bld)\\$_\""
+			" \\\n\tZ:\$(EPOCSTATLINK$Bld)\/$_"
 		);
 	}
 	foreach (@LibList) {
 		&main::Output(
-			" \\\n\t\"\$(EPOCLINK$Bld)\\$_\""
+			" \\\n\tZ:\$(EPOCLINK$Bld)\/$_"
 		);
 	}
 	&main::Output(
 		"\n",
 		"\n"
 	);
+# ------------------
+
 
 	&main::Output(
-		"LINK_OBJS="
+		"LINK_OBJS_",$Bld,"="
 	);
 	foreach (@BaseSrcList) {
 		&main::Output(
 			" \\\n",
-			"\t\"\$(EPOCBLD$Bld)\\$_.obj\""
+			"\t\$(EPOCBLD$Bld)\/$_.obj"
 		);
 	}
 	if ($Win32Resrc) {
 		&main::Output(
 			" \\\n",
-			"\t\"\$(EPOCBLD$Bld)\\",&main::Path_Split('Base',$Win32Resrc),".res\""
+			"\t\$(EPOCBLD$Bld)\/",&main::Path_Split('Base',$Win32Resrc),".res"
+		);
+	}
+	&main::Output(
+		"\n",
+		"\n"
+	);
+#
+# extra obj defs to satisfy wine
+#
+	&main::Output(
+		"LINK_OBJS_",$Bld,"_WIN="
+	);
+	foreach (@BaseSrcList) {
+		&main::Output(
+			" \\\n",
+			"\tZ:\$(EPOCBLD$Bld)\/$_.obj"
+		);
+	}
+	if ($Win32Resrc) {
+		&main::Output(
+			" \\\n",
+			"\tZ:\$(EPOCBLD$Bld)\/",&main::Path_Split('Base',$Win32Resrc),".res"
 		);
 	}
 	&main::Output(
@@ -773,10 +884,10 @@ sub PMBld {
 
 	if ($BasicTrgType=~/^DLL$/o) {
 		&main::OutFormat(
-			"STAGE1_LINK_FLAGS="
+			"STAGE1_LINK_FLAGS_",$Bld,"="
 		);
 		&main::OutFormat(
-			"\"\$(EPOCSTATLINK$Bld)\\$FirstLib\""
+			"Z:\$(EPOCSTATLINK$Bld)\/$FirstLib" # 4 extra backslashes to keep Wine happy
 		);
 		foreach (@Win32LibList) {
 			&main::OutFormat(
@@ -784,7 +895,7 @@ sub PMBld {
 			);
 		}
 		&main::OutFormat(
-			" \$(LIBS) /nologo$BaseAddressFlag /entry:\"_E32Dll\" /subsystem:windows /dll"
+			" \$(LIBS_",$Bld,"_WIN) /nologo$BaseAddressFlag /entry:\"_E32Dll\" /subsystem:windows /dll"
 		);
 		if ($Bld=~/DEB$/o) {
 			&main::OutFormat(
@@ -792,7 +903,7 @@ sub PMBld {
 			);
 		}
 		&main::OutFormat(
-			" /incremental:no /PDBTYPE:SEPT /machine:IX86 /nodefaultlib /include:\"",'?_E32Dll@@YGHPAXI0@Z',"\" /out:\"\$(EPOCBLD$Bld)\\$Trg\" $WarningLevel"
+			" /incremental:no /PDBTYPE:SEPT /machine:IX86 /nodefaultlib /include:\"",'?_E32Dll@@YGHPAXI0@Z',"\" /out:\"\$(EPOCBLD$Bld)/$Trg\" $WarningLevel"
 		);
 		&main::Output(
 			"\n",
@@ -801,13 +912,13 @@ sub PMBld {
 	}
 
 	&main::OutFormat(
-		'LINK_FLAGS='
+		"LINK_FLAGS_",$Bld,"="
 	);
 	if ($BasicTrgType=~/^(EXE|DLL)$/o) {
 # tools hack
 		unless (&main::Plat eq 'TOOLS') {
 			&main::OutFormat(
-				" \"\$(EPOCSTATLINK$Bld)\\$FirstLib\""
+				" Z:\$(EPOCSTATLINK$Bld)\/$FirstLib"
 			);
 		}
 # tools hack end
@@ -818,7 +929,7 @@ sub PMBld {
 		);
 	}
 	&main::OutFormat(
-		' $(LIBS) /nologo'
+		" \$(LIBS_",$Bld,"_WIN) /nologo"
 	);
 	if ($BasicTrgType=~/^DLL$/o) {
 		&main::OutFormat(
@@ -846,7 +957,7 @@ sub PMBld {
 	}
 	if ($BasicTrgType=~/^DLL$/o) {
 		&main::OutFormat(
-			" /dll \"\$(EPOCBLD$Bld)\\$BaseTrg.exp\""
+			" /dll \"\$(EPOCBLD$Bld)/$BaseTrg.exp\""
 		);
 	}
 	if ($BasicTrgType=~/^(DLL|EXE)$/o) {
@@ -882,7 +993,7 @@ sub PMBld {
 	}
 # tools hack end
 	&main::OutFormat(
-		" /out:\"\$(EPOCTRG$Bld)\\\$(TRGDIR)\\$Trg\""
+		" /out:\"\$(EPOCTRG$Bld)/\$(TRGDIR)/$Trg\""
 	);
 	if ($BasicTrgType=~/^(DLL|EXE)$/o) {
 		&main::OutFormat(
@@ -895,47 +1006,46 @@ sub PMBld {
 	);
 
 	&main::Output(
-		"\"\$(EPOCTRG$Bld)\\\$(TRGDIR)\\$Trg\" : \$(LINK_OBJS)"
+		"\$(EPOCTRG$Bld)\/\$(TRGDIR)\/$Trg: \$(LINK_OBJS_",$Bld,")"
 	);
 	if (-e $DefFile) { # effectively "if project frozen ..."
 		&main::Output(
-			" \"$DefFile\""
+			" $DefFile"
 		);
 	}
 	if ($BasicTrgType=~/^(DLL|EXE)$/o) {
 # tools hack
 		unless (&main::Plat eq 'TOOLS') {
 			&main::Output(
-				" \"\$(EPOCSTATLINK$Bld)\\$FirstLib\""
+				" \$(EPOCSTATLINK$Bld)\/$FirstLib"
 			);
 		}
 	}
 # tools hack end
 	&main::Output(
-		" \$(LIBS)\n"
+		" \$(LIBS_",$Bld,")\n"
 	);
 
 
 #	Link by name first time round for dlls
 	if ($BasicTrgType=~/^DLL$/o) {
 		&main::Output(
-			"\tlink.exe \@<<\n",
-			"\t\t\$(STAGE1_LINK_FLAGS) \$(LINK_OBJS)\n",
-			"<<\n",
-			"\tdel \"\$(EPOCBLD$Bld)\\$Trg\"\n",
-			"\tdel \"\$(EPOCBLD$Bld)\\$BaseTrg.exp\"\n"
+			"\twine LINK.EXE ",
+			"\$(STAGE1_LINK_FLAGS_",$Bld,") \$(LINK_OBJS_",$Bld,"_WIN)\n",
+			"\trm -f \$(EPOCBLD$Bld)\/$Trg\n",
+			"\trm -f \$(EPOCBLD$Bld)\/$BaseTrg.exp\n"
 		);
 
 #		Generate an export info file
 		&main::Output(
-			"\tdumpbin /exports /out:\"\$(EPOCBLD$Bld)\\$BaseTrg.inf\" \"\$(EPOCBLD$Bld)\\$BaseTrg.lib\"\n",
-			"\tdel \"\$(EPOCBLD$Bld)\\$BaseTrg.lib\"\n"
+			"\twine DUMPBIN.EXE /exports /out:\"\$(EPOCBLD$Bld)/$BaseTrg.inf\" Z:\$(EPOCBLD)/$Bld2/$BaseTrg.lib\n",
+			"\trm -f \$(EPOCBLD$Bld)\/$BaseTrg.lib\n"
 		);
 
 #		call makedef to reorder the export information
 		&main::Output(
-#			call perl on the script here so nmake will die if there are errors - this doesn't happen if calling perl in a batch file
-			"\tperl -S makedef.pl -Inffile \"\$(EPOCBLD$Bld)\\$BaseTrg.inf\""
+#			call perl on the script here so make will die if there are errors - this doesn't happen if calling perl in a batch file
+			"\tperl -S makedef.pl -Inffile \"\$(EPOCBLD$Bld)\/$BaseTrg.inf\""
 		);
 		if (-e $DefFile) { # effectively "if project frozen ..."
 			&main::Output(
@@ -956,48 +1066,48 @@ sub PMBld {
 		}
 		&main::Output(
 			" \"\$(EPOCBLD)$BaseTrg.def\" \n",
-			"\tdel \"\$(EPOCBLD$Bld)\\$BaseTrg.inf\"\n"
+			"\trm -f \$(EPOCBLD$Bld)\/$BaseTrg.inf\n"
 		);
 
 		# create the export object from the .DEF file
 		&main::Output(
-			"\tlib.exe  /nologo /machine:i386 /nodefaultlib /name:\"$Trg\" /def:\"\$(EPOCBLD)$BaseTrg.def\" /out:\"\$(EPOCBLD$Bld)\\$BaseTrg.lib\"\n"
+			"\twine LIB.EXE  /nologo /machine:i386 /nodefaultlib /name:\"$Trg\" /def:\"\$(EPOCBLD)$BaseTrg.def\" /out:\"\$(EPOCBLD$Bld)/$BaseTrg.lib\"\n"
 		);
 		if (&main::ExportUnfrozen) {
 			&main::Output(
-			"\tcopy \"\$(EPOCBLD$Bld)\\$BaseTrg.lib\" \"\$(EPOCLIB)UDEB\\$BaseTrg.LIB\"\n"
+			"\tcp \$(EPOCBLD$Bld)\/$BaseTrg.lib \$(EPOCLIB)udeb\/$BaseTrg.lib\n"
 			);
 		}
 		&main::Output(
-			"\tdel \"\$(EPOCBLD$Bld)\\$BaseTrg.lib\"\n"
+			"\trm -f \$(EPOCBLD$Bld)\/$BaseTrg.lib\n"
 		);
 	}
 
 	if ($BasicTrgType=~/^(DLL|EXE)$/o) {
 		&main::Output(
-			"\tlink.exe \@<<\n"
+			"\twine LINK.EXE \\\n"
 		);
 	}
 	elsif ($BasicTrgType=~/^LIB$/o) {
 		&main::Output(
-			"\tlib.exe \@<<\n"
+			"\twine LIB.EXE \\\n"
 		);
 	}
 	&main::Output(
-		"\t\t\$(LINK_FLAGS) \$(LINK_OBJS)\n",
-		"<<\n"
+		"\t\t\$(LINK_FLAGS_",$Bld,") \$(LINK_OBJS_",$Bld,"_WIN)\n",
+#		"<<\n"
 	);
 
 	if ($BasicTrgType=~/^DLL$/o) {
 		&main::Output(
-			"\tdel \"\$(EPOCBLD$Bld)\\$BaseTrg.exp\"\n"
+			"\trm -f \$(EPOCBLD$Bld)\/$BaseTrg.exp\n"
 		);
 	}
 
 # tools hack
 	if (&main::Plat eq 'TOOLS') {
 		&main::Output(
-			"\tcopy \"\$(EPOCTRG$Bld)\\\$(TRGDIR)\\$Trg\" \"",&main::EPOCToolsPath,"$Trg\"\n"
+			"\tcp \"\$(EPOCTRG$Bld)/\$(TRGDIR)/$Trg\" \"",&main::EPOCToolsPath,"$Trg\"\n"
 		);
 	}
 # tools hack end
@@ -1038,23 +1148,23 @@ sub PMBitMapBld {
 
 	my $ChopBitMapTrgFullPath="\$(EPOCTRG$Bld)";
 	if ($$BitMapRef{TrgPath}) {
-		$ChopBitMapTrgFullPath.="\\$$BitMapRef{TrgPath}";
+		$ChopBitMapTrgFullPath.="/$$BitMapRef{TrgPath}";
 		chop $ChopBitMapTrgFullPath;
 	}
 
 	&main::Output(
-		"\"$ChopBitMapTrgFullPath\\$$BitMapRef{Trg}\" :"
+		      "$ChopBitMapTrgFullPath\/$$BitMapRef{Trg}:"
 	);
 	my $SrcRef;
 	foreach $SrcRef (@{$$BitMapRef{Source}}) {
 		&main::Output(
-			" \"$$SrcRef{Src}\""
+			" $$SrcRef{Src}"
 		);
 	}
 	&main::Output(
 		"\n",
-		"\t\@if not exist \"$ChopBitMapTrgFullPath\" perl -S emkdir.pl \"$ChopBitMapTrgFullPath\"\n",
-		"\tbmconv <<\n",
+		"\t\@mkdir -p \"$ChopBitMapTrgFullPath\"\n",
+		"\twine \$(EPOCROOT)/epoc32/tools/bmconv.exe ",
 		" /q"
 	);
 	if ($$BitMapRef{Hdr}) {
@@ -1063,24 +1173,24 @@ sub PMBitMapBld {
 		);
 	}
 	&main::Output(
-		" $ChopBitMapTrgFullPath\\$$BitMapRef{Trg}\n"
+		" /.$ChopBitMapTrgFullPath/$$BitMapRef{Trg}"
 	);
 	foreach $SrcRef (@{$$BitMapRef{Source}}) {
 		&main::Output(
-			" /$$SrcRef{ClDepth}$$SrcRef{Src}\n"
+			" \\\n\t/$$SrcRef{ClDepth}$$SrcRef{Src}"
 		);
 	}
 	&main::Output(
-		"<<\n"
+		"\n"
 	);
 	if ($$BitMapRef{Hdr}) {
 		&main::Output(
-			"\tcall <<\"MayRewriteHdr.bat\"\n",
-			"\t\@echo off\n",
-			"\tdiff \"$RTWTmpBitMapHdr\" \"$RTWBitMapHdr\" >NUL\n",
-			"\tif errorlevel==1 copy \"$TmpBitMapHdr\" \"$BitMapHdr\"\n",
-			"<<\n",
-			"\tdel \"$TmpBitMapHdr\"\n",
+#			"\tcall <<\"MayRewriteHdr.bat\"\n",
+#			"\t\@echo off\n",
+#			"\tdiff \"$RTWTmpBitMapHdr\" \"$RTWBitMapHdr\" >NUL\n",
+			"\tcp $TmpBitMapHdr $BitMapHdr\n",
+#			"<<\n",
+			"\trm -f $TmpBitMapHdr\n",
 		);
 	}
 	&main::Output(
@@ -1115,7 +1225,7 @@ sub PMResrcDepend {
 	foreach (@DepList) {
 		&main::Output(
 			" \\\n",
-			"\t\"$_\""
+			"\t$_"
 		);
 	}
 	&main::Output(
@@ -1127,39 +1237,39 @@ sub PMResrcDepend {
 sub PMResrcBld {
 	my $BaseResrc=&main::BaseResrc;
 	my $Bld=&main::Bld;
-	my @ChopRTWSysIncPaths=&main::Path_Chop(&main::Path_RltToWork(&main::SysIncPaths));
-	my @ChopRTWUserIncPaths=&main::Path_Chop(&main::Path_RltToWork(&main::UserIncPaths));
+	my @ChopRTWSysIncPaths=&main::Path_RltToWork(&main::SysIncPaths);
+	my @ChopRTWUserIncPaths=&main::Path_RltToWork(&main::UserIncPaths);
 	my @LangList=&main::LangList;
 	my $Resrc=&main::Resrc;
 	my $ResrcIsSys=&main::ResrcIsSys;
 	my $RTWSrcPath=&main::Path_RltToWork(&main::SrcPath);
 	my $ChopRTWSrcPath=&main::Path_Chop($RTWSrcPath);
 
-	my $ResrcHdr=join '', &main::EPOCIncPath(), $BaseResrc, '.RSG';
+	my $ResrcHdr=join '', &main::EPOCIncPath(), $BaseResrc, '.rsg';
 	my $RTWResrcHdr=&main::Path_RltToWork($ResrcHdr);
 	
 	my $Lang;
 	foreach $Lang (@LangList) {
 		&main::Output(
-			"\"\$(EPOCTRG$Bld)\\"
+			"\$(EPOCTRG$Bld)\/"
 		);
 		if ($ResrcIsSys) {
 			&main::Output(
-				"\$(DATADIR)\\"
+				"\$(DATADIR)\/"
 			);
 		}
 		else {
 			&main::Output(
-				"\$(TRGDIR)\\"
+				"\$(TRGDIR)\/"
 			);
 		}
 		&main::Output(
-			"$BaseResrc.r$Lang\" : \"$RTWSrcPath$Resrc\" \$(DEPEND)\n",
-			"\tperl -S epocrc.pl -I \"$ChopRTWSrcPath\""
+			"$BaseResrc.r$Lang : $RTWSrcPath$Resrc \$(DEPEND)\n",
+			"\tperl -S epocrc.pl -I $ChopRTWSrcPath"
 		);
 		foreach (@ChopRTWUserIncPaths) {
 			&main::Output(
-				" -I \"$_\""
+				" -I $_"
 			);
 		}
 		&main::Output(
@@ -1167,18 +1277,15 @@ sub PMResrcBld {
 		);
 		foreach (@ChopRTWSysIncPaths) {
 			&main::Output(
-				" -I \"$_\""
+				" -I $_"
 			);
 		}
 		&main::Output(
 			" -DLANGUAGE_$Lang -u \"$RTWSrcPath$Resrc\" ",
 			"-o\$\@ -h\"$RTWSrcPath$BaseResrc.rs~\" -t\"\$(EPOCBLD$Bld)\"\n",
-			"\tcall <<\"MayRewriteHdr.bat\"\n",
-			"\t\@echo off\n",
-			"\tdiff \"$RTWSrcPath$BaseResrc.rs~\" \"$RTWResrcHdr\" >NUL\n",
-			"\tif errorlevel==1 copy \"$RTWSrcPath$BaseResrc.rs~\" \"$ResrcHdr\"\n",
-			"<<\n",
-			"\tdel \"$RTWSrcPath$BaseResrc.rs~\"\n",
+			"\trm -f $RTWSrcPath$BaseResrc.rpp\n",
+			"\tcp $RTWSrcPath$BaseResrc.rs~ $ResrcHdr\n",
+			"\trm -f $RTWSrcPath$BaseResrc.rs~\n",
 			"\n"
 		);
 	}
@@ -1211,7 +1318,7 @@ sub PMAifDepend {
 	foreach (@DepList) {
 		&main::Output(
 			" \\\n",
-			"\t\"$_\""
+			"\t$_"
 		);
 	}
 	&main::Output(
@@ -1231,25 +1338,25 @@ sub PMAifBld {
 	my $ChopBldPath=&main::Path_Chop(&main::BldPath);
 
 	&main::Output(
-		"\"\$(EPOCTRG$Bld)\\\$(TRGDIR)\\$$AifRef{Trg}\" : \"$$AifRef{Dir}$$AifRef{Resrc}\" \$(DEPEND)"
+		"\$(EPOCTRG$Bld)\/\$(TRGDIR)\/$$AifRef{Trg}: $$AifRef{Dir}$$AifRef{Resrc} \$(DEPEND)"
 	);
 	if (@{$$AifRef{BitMaps}}) { # bitmaps aren't essential
 		my $BitMap;
 		foreach $BitMap (@{$$AifRef{BitMaps}}) {
 			&main::Output(
-				" \"$$AifRef{Dir}$BitMap\""
+				" $$AifRef{Dir}$BitMap"
 			);
 		}
 	}
 	&main::Output(
 		"\n",
 		"\tperl -S epocaif.pl -o\$@ ",
-		"\"$ChopRTWAifDir\\$$AifRef{Resrc}\" ",
+		"\"$ChopRTWAifDir\/$$AifRef{Resrc}\" ",
 		"\\\n\t\t",
-		"-t\"$ChopBldPath\" ",
+		"-t. ",
 		"\\\n\t\t"
 	);
-	if (@{$$AifRef{BitMaps}}) { 
+	if (@{$$AifRef{BitMaps}}) {
 		&main::Output(
 			"-b\""
 		);
@@ -1308,7 +1415,7 @@ sub PMSrcDepend {
 	);
 	foreach (@DepList) {
 		&main::Output(
-		" \\\n\t\"$_\""
+		" \\\n\t$_"
 		);
 	}
 	&main::Output(
@@ -1347,12 +1454,13 @@ sub PMSrcBldDepend {
 sub PMEndSrcBld {
 	my $BaseSrc=&main::BaseSrc;
 	my $Bld=&main::Bld;
-	my $Src=ucfirst lc &main::Src;
+#	my $Src=ucfirst lc &main::Src;
+	my $Src=&main::Src;
 	my $SrcPath=&main::SrcPath;
 
 	&main::Output(
-		"\"\$(EPOCBLD$Bld)\\$BaseSrc.obj\" \"\$(EPOCBLD$Bld)\\$BaseSrc.sbr\" : \"$SrcPath$Src\" \$(DEPEND$Bld)\n",
-		"\t\$(CL$Bld) /Fo\"\$(EPOCBLD$Bld)/\" /GF /c \"$SrcPath$Src\"\n",
+		"\$(EPOCBLD$Bld)\/$BaseSrc.obj \$(EPOCBLD$Bld)\/$BaseSrc.sbr : $SrcPath$Src \$(DEPEND$Bld)\n",
+		"\t\$(CL$Bld) /Fo\$(EPOCBLD$Bld)/ /GF /c Z:$SrcPath$Src\n",
 		"\n",
 #		assembler listing target - currently does nothing
 		"LISTING$Bld$BaseSrc :\n",
@@ -1381,7 +1489,7 @@ sub PMEndSrcList {
 		);
 		foreach (@DepList) {
 			&main::Output(
-				" \\\n\t\"$_\""
+				" \\\n\t$_"
 			);
 		}
 		&main::Output(
@@ -1392,7 +1500,7 @@ sub PMEndSrcList {
 		my $Bld;
 		foreach $Bld (@BldList) {
 			&main::Output(
-				"\"\$(EPOCBLD$Bld)\\",&main::Path_Split('Base',$Win32Resrc),".res\" : \"$Win32Resrc\" \$(DEPEND)\n",
+				"\$(EPOCBLD$Bld)\/",&main::Path_Split('Base',$Win32Resrc),".res : $Win32Resrc \$(DEPEND)\n",
 				"\trc /l 0x809 /fo\$\@ /i \"",&main::Path_Chop(&main::Path_Split('Path',$Win32Resrc)),"\" \"$Win32Resrc\"\n",
 				"\n"
 			);
diff --git a/cshlpcmp.pl b/cshlpcmp.pl
index cda9397..7cfb31c 100644
--- a/cshlpcmp.pl
+++ b/cshlpcmp.pl
@@ -1,4 +1,4 @@
-#!perl
+#!/usr/bin/perl
 ################################################################################
 #
 # Program: cshlpcmp 
@@ -39,23 +39,23 @@ Independent JPEG Group.
 
 #add the local library path to the global one
 use FindBin;
-use lib $FindBin::Bin."\\perllib","$FindBin::Bin\\cshlpcmp\\perl";
+use lib $FindBin::Bin."/perllib","$FindBin::Bin/cshlpcmp/perl";
 
 #Standard libraries
 use Carp;
 use strict;
 
 #use the DOM xml module
-use XML::DOM;
+use xml::dom;
 
 # use the devtools library
 use devtools;
 
 #objects
-use ProjFile;
+use projfile;
 use args;
 use params;
-use Conv; #rtf2Xml converter
+use conv; #rtf2Xml converter
 
 # global reference to the commandline parameters
 $main::params=undef;
@@ -94,7 +94,9 @@ sub main
 
     my $projectFile = New CProjFile;
 
-    $projectFile->Parse($main::params->ParamItem("projectfile")->Value());
+    my $file = $main::params->ParamItem("projectfile")->Value();
+    $file =~ s/\\/\//g;
+    $projectFile->Parse($file);
 
     #create the converter object
     my $converter = New CConverter($projectFile);
@@ -134,9 +136,11 @@ sub Initilise
     $main::params = $args->ParseCommandLine(\@ARGV);
 
     # if a log file was requested
-    if($main::params->Exists("logFile"))
+    if($main::params->Exists("logfile"))
 		{
-		my $log = New CLog($main::params->ParamItem("logFile")->Value());
+		my $logfile = $main::params->ParamItem("logfile")->Value();
+		$logfile =~ s/\\/\//g;
+		my $log = New CLog($logfile);
 		}
 
 	my $log = New CLog(); # So we can error in this function
diff --git a/cshlpcmp/perl/asptmlfl.pm b/cshlpcmp/perl/asptmlfl.pm
index 3c6098b..239d28b 100644
--- a/cshlpcmp/perl/asptmlfl.pm
+++ b/cshlpcmp/perl/asptmlfl.pm
@@ -1303,9 +1303,13 @@ sub _ProcGraphicNodes
 							#make a copy of the graphic node
 							my $graphicNodeCopy = $graphicNode->cloneNode(1);
 							
+							my $epoc = $epocFileName;
+							my $html = $htmlFileName;
+							$epoc =~ s/\//\\/g;
+							$html =~ s/\//\\/g;
 							$graphicNodeCopy->removeAttribute("filename");
-							$graphicNodeCopy->setAttribute("epocfilename",$epocFileName);
-							$graphicNodeCopy->setAttribute("htmlfilename",$htmlFileName);
+							$graphicNodeCopy->setAttribute("epocfilename",$epoc);
+							$graphicNodeCopy->setAttribute("htmlfilename",$html);
 							
 							#store this mbm graphic
 							$self->_iMbmList->AddItem($epocFileName,$graphicNodeCopy);
diff --git a/cshlpcmp/perl/cshlpfl.pm b/cshlpcmp/perl/cshlpfl.pm
index fa14b0c..50270ca 100644
--- a/cshlpcmp/perl/cshlpfl.pm
+++ b/cshlpcmp/perl/cshlpfl.pm
@@ -137,10 +137,15 @@ sub ToEPOCHelp
 	my $self = shift;
 
 	# call the cshlpwtr application to convert the CsHlp file to an EPOCHelp file
-	my $command= $self->_iCSHlpWtrExe." \"-if".$self->_iCsHlpFile."\" \"-of".$self->_iEPOCHelpFile."\"";
+	my $CsHlpFile = $self->_iCsHlpFile;
+	my $EPOCHelpFile = $self->_iEPOCHelpFile;
+	$CsHlpFile =~ s/\//\\/g;
+	$EPOCHelpFile =~ s/\//\\/g;
+	my $command= "wine ".$self->_iCSHlpWtrExe." \"-if".$CsHlpFile."\" \"-of".$EPOCHelpFile."\"";
 
 	$self->_iLog->Log($command."\n");
 
+	$command =~ s/\\/\\\\/g;
 	my $return=system($command);
 
 	#check if cshlpwtr managed to run
diff --git a/cshlpcmp/perl/csptmlfl.pm b/cshlpcmp/perl/csptmlfl.pm
index e7b2b9e..e26dd78 100644
--- a/cshlpcmp/perl/csptmlfl.pm
+++ b/cshlpcmp/perl/csptmlfl.pm
@@ -1569,9 +1569,10 @@ sub _ProcGraphicLinkNode
 	#make the fileName 
 	if ( ($archive !~ /[\\\/]$/) && ($archive ne "") )
 		{
-		$archive = $archive."\\";
+		$archive = $archive."\/";
 		}
 	my $fileName=$archive.$name;
+	$fileName =~ s/\\/\//g;
 
 	#check that the mbm graphic file exists and is not zero size
 	if(! -s $self->_iGraphicsDir.$fileName.".mbm")
diff --git a/cshlpcmp/perl/custfile.pm b/cshlpcmp/perl/custfile.pm
index 4684806..6b02476 100644
--- a/cshlpcmp/perl/custfile.pm
+++ b/cshlpcmp/perl/custfile.pm
@@ -1055,6 +1055,7 @@ sub _GetGraphicID($)
 	my $self=shift;
 
 	my($aFileName) = @_;
+	$aFileName =~ s/\\/\//g;
 
 	# get the epoc filename for the graphic
 	my($epocFileName)=$aFileName.".mbm";
@@ -1106,6 +1107,7 @@ sub _CreateGraphicNode($)
 	{
 	my $self=shift;
 	my($aGraphicFileName)=@_;
+	$aGraphicFileName =~ s/\//\\/g;
 
 	#create the graphic tag
 	my $element = $self->_iCsHlpDom->createElement("graphic");
diff --git a/cshlpcmp/perl/parastyle.pm b/cshlpcmp/perl/parastyle.pm
index a572910..04cd622 100644
--- a/cshlpcmp/perl/parastyle.pm
+++ b/cshlpcmp/perl/parastyle.pm
@@ -17,7 +17,7 @@ use strict;
 
 use devtools;
 use log;
-use XML::DOM;
+use xml::dom;
 
 ################################################################################
 #
diff --git a/cshlpcmp/perl/projfile.pm b/cshlpcmp/perl/projfile.pm
index 5007b4f..1168cff 100644
--- a/cshlpcmp/perl/projfile.pm
+++ b/cshlpcmp/perl/projfile.pm
@@ -42,6 +42,7 @@ sub New
 
 	#get the current working directory
 	my $cwd = cwd();
+	$cwd =~ s/([^\/])$/$1\//; # append a slash if one isn't found
 	
 	my $self  = {};
 
@@ -335,6 +336,7 @@ sub Parse($)
 	{
 	my $self = shift;
 	my($aProjectFile)=@_;
+	$aProjectFile =~ s/\\/\//g;
 
 	#get a new xml parsing object
 	my $parser = new XML::DOM::Parser;
@@ -512,6 +514,7 @@ sub _ProcDirectoriesNodes($)
 					$text = "";
 					}
 				my $path = $self->_RelateToDir($projectDir, $text);
+				$path =~ s/\\/\//g;
 
 				if($tagName eq "input")
 					{
@@ -534,7 +537,7 @@ sub _ProcDirectoriesNodes($)
 							  substr($self->_iOutputDir(), 0, index($self->_iOutputDir(),':')+1);
 							}
 						$nullFile = $nullFile."\\nul";
-						open(NULL,">>$nullFile") or $self->_iLog->LogDie("The output directory '".$self->_iOutputDir."' is on a drive that doesn't exist, so cannot be created.");
+#						open(NULL,">>$nullFile") or $self->_iLog->LogDie("The output directory '".$self->_iOutputDir."' is on a drive that doesn't exist, so cannot be created.");
 
 						mkpath($self->_iOutputDir);
 						}
@@ -568,7 +571,7 @@ sub _ProcDirectoriesNodes($)
 							$nullFile = substr($self->_iWorkingDir(),0,index($self->_iWorkingDir(),':')+1);
 							}
 						$nullFile = $nullFile."\\nul";
-						open(NULL,">>$nullFile") or $self->_iLog->LogDie("The working directory '".$self->_iWorkingDir."' is on a drive that doesn't exist, so cannot be created.");
+#						open(NULL,">>$nullFile") or $self->_iLog->LogDie("The working directory '".$self->_iWorkingDir."' is on a drive that doesn't exist, so cannot be created.");
 
 						mkpath($self->_iWorkingDir);
 						}
@@ -618,7 +621,7 @@ sub _RelateToDir($$)
 
 	if ($path =~ /[^\\\/]$/)
 		{
-		$path = $path."\\";
+		$path = $path."\/";
 		}
 	
 	return $path;
@@ -678,13 +681,13 @@ sub _RelateTo($$)
 		$path = $path.$aPath; # Move to the new path
 		}
 
-	# Convert unix slashes to DOS ones
-	$path =~ s/\//\\/g;
+	# Convert DOS slashes to unix ones
+	$path =~ s/\\/\//g;
 
 	# Remove /dir/.. which cancel out
-	while ($path =~ /\\[^\.\\]+\\\.\./)
+	while ($path =~ /\/[^\.\/]+\/\.\./)
 		{
-		$path =~ s/\\[^\.\\]+\\\.\.//;
+		$path =~ s/\/[^\.\/]+\/\.\.//;
 		}
 	
 	return $path;
diff --git a/cshlpcmp/perl/rtffile.pm b/cshlpcmp/perl/rtffile.pm
index 8f64e10..273b6ca 100644
--- a/cshlpcmp/perl/rtffile.pm
+++ b/cshlpcmp/perl/rtffile.pm
@@ -106,12 +106,13 @@ sub ToPtml
     my($rtfFile)=ExtractFileNameNoExt($self->_iRtfFile);
 
     # call the rtf2ptml application to convert the rtf files to ptml
-    $inputDir =~ s/([~\\\/])$/$1\//;
-    $outputDir =~ s/([~\\\/])$/$1\//;
+    $inputDir =~ s/([^\\\/])$/$1\//;
+    $outputDir =~ s/([^\\\/])$/$1\//;
     my($command)="rtf2ptml \"-id".$inputDir."\" \"-od".$outputDir."\" \"-ox.ptml.xml\" \"-dtd".$self->_GetDTDUrl()."\" \"-xsl".$self->_GetXSLUrl()."\" \"".$rtfFile."\"";
 
     $self->_iLog->Log($command."\n");
 
+    $command =~ s/\\/\\\\/g;
     my $return=system($command);
 
     #check if rtf2ptml managed to run
diff --git a/defutl.pm b/defutl.pm
index 32359ba..cba900a 100644
--- a/defutl.pm
+++ b/defutl.pm
@@ -8,7 +8,7 @@
 # General Def file utilities
 #---------------------------
 
-package Defutl;
+package defutl;
 
 require Exporter;
 @ISA=qw(Exporter);
diff --git a/e32env.pm b/e32env.pm
index bbc7505..ef73e55 100644
--- a/e32env.pm
+++ b/e32env.pm
@@ -6,7 +6,7 @@
 # Contains information for makmake and associated e32tools perl programs
 # within the Epoc32 Environment
 
-package E32env;
+package e32env;
 
 
 use vars qw(%Data);
@@ -14,28 +14,26 @@ use vars qw(%Data);
 BEGIN {
 	my $epocroot = $ENV{EPOCROOT};
 	die "ERROR: Must set the EPOCROOT environment variable\n" if (!defined($epocroot));
-	$epocroot =~ s-/-\\-go;	# for those working with UNIX shells
 	die "ERROR: EPOCROOT must not include a drive letter\n" if ($epocroot =~ /^.:/);
-	die "ERROR: EPOCROOT must be an absolute path without a drive letter\n" if ($epocroot !~ /^\\/);
+	die "ERROR: EPOCROOT must be an absolute path without a drive letter\n" if ($epocroot !~ /^\//);
 	die "ERROR: EPOCROOT must not be a UNC path\n" if ($epocroot =~ /^\\\\/);
-	die "ERROR: EPOCROOT must end with a backslash\n" if ($epocroot !~ /\\$/);
+	die "ERROR: EPOCROOT must end with a slash\n" if ($epocroot !~ /\/$/);
 	die "ERROR: EPOCROOT must specify an existing directory\n" if (!-d $epocroot);
 
-	$epocroot=~ s-\\$--;		# chop trailing \\
+	$epocroot=~ s-\/$--;		# chop trailing /
 
-	$Data{EPOCPath} = $epocroot."\\EPOC32\\";
+	$Data{EPOCPath} = $epocroot."/epoc32/";
 
-	$Data{EPOCIncPath} = $epocroot."\\EPOC32\\INCLUDE\\";
-	$Data{BldPath} = $epocroot."\\EPOC32\\BUILD\\";
+	$Data{EPOCIncPath} = $epocroot."/epoc32/include/";
+	$Data{BldPath} = $epocroot."/epoc32/build/";
 #regression hack
-#	$Data{LinkPath} = $epocroot."\\EPOC32\\LIBRARY\\";
-	$Data{LinkPath} = $epocroot."\\EPOC32\\RELEASE\\";
+	$Data{LinkPath} = $epocroot."/epoc32/release/";
 #regression hack end
-	$Data{RelPath} = $epocroot."\\EPOC32\\RELEASE\\";
-	$Data{EPOCToolsPath} = $epocroot."\\EPOC32\\TOOLS\\";
-	$Data{RomPath} = $epocroot."\\EPOC32\\ROM\\";
+	$Data{RelPath} = $epocroot."/epoc32/release/";
+	$Data{EPOCToolsPath} = $epocroot."/epoc32/tools/";
+	$Data{RomPath} = $epocroot."/epoc32/rom/";
 
-	$Data{DataPath} = "Z\\SYSTEM\\DATA\\";
+	$Data{DataPath} = "z/system/data/";
 }
 
 1;
diff --git a/e32plat.pm b/e32plat.pm
index b06ae87..551eb12 100644
--- a/e32plat.pm
+++ b/e32plat.pm
@@ -1,3 +1,5 @@
+#!/usr/bin/perl -w
+#
 # E32PLAT.PM
 #
 # Copyright (c) 1997-1999 Symbian Ltd.  All rights reserved.
@@ -5,11 +7,11 @@
 
 
 # Module providing platform details for platforms supported
-# by Epoc
+# by Symbian OS
 #
 # all data is uppercase
 
-package E32Plat;
+package e32plat;
 
 require Exporter;
 @ISA=qw(Exporter);
@@ -35,7 +37,8 @@ sub Plat_SetVerbose () {
 my %BldLists=(
 	EPOC32=>['UREL','UDEB'],
 	WINS=>['UDEB','UREL'],
-	TOOLS=>['DEB','REL']
+	TOOLS=>['DEB','REL'],
+	linux=>['UDEB','UREL']
 );
 
 my %BldMacros=(
@@ -68,6 +71,17 @@ my %Plat=(
 	MCGA=>{
 		place_holder=>1		# so platform is defined
 	},
+	MCGM=>{
+		ABI=>'MCORE',
+		ASSPABI=>'MCORE',
+		CPU=>'MCORE',
+	},
+	MCORE=>{
+		ABI=>'MCORE',
+		ASSPABI=>'',
+		CPU=>'MCORE',
+		Generic=>1,
+	},
 	MEIG=>{
 		place_holder=>1		# so platform is defined
 	},
@@ -127,15 +141,15 @@ my %Plat=(
 		Compiler=>'VC32',
 		CPU=>'TOOLS',
 		OS=>'TOOLS',
-		MakeMod=>'Cl_win',
+		MakeMod=>'cl_win',
 	},
 	VC6=>{
 		ABI=>'WINS',
 		ASSPABI=>'',
 		Compiler=>'VC32',
 		CPU=>'WINS',
-		Ext=>'.DSP',
-		MakeMod=>'Ide_vc6',
+		Ext=>'.dsp',
+		MakeMod=>'ide_vc6',
 		OS=>'WINS',
 		Real=>'WINS',
 		UsrHdrsOnly=>1,
@@ -145,8 +159,8 @@ my %Plat=(
 		ASSPABI=>'',
 		Compiler=>'VC32',
 		CPU=>'TOOLS',
-		Ext=>'.DSP',
-		MakeMod=>'Ide_vc6',
+		Ext=>'.dsp',
+		MakeMod=>'ide_vc6',
 		OS=>'TOOLS',
 		Real=>'TOOLS',
 		UsrHdrsOnly=>1,
@@ -156,9 +170,9 @@ my %Plat=(
 		ASSPABI=>'',
 		Compiler=>'VC32',
 		CPU=>'WINS',
-		Ext=>'.DSP',
+		Ext=>'.dsp',
 		OS=>'WINS',
-		MakeMod=>'Ide_vc6',
+		MakeMod=>'ide_vc6',
 		Real=>'WINC',
 		UsrHdrsOnly=>1
 	},
@@ -167,7 +181,7 @@ my %Plat=(
 		ASSPABI=>'',
 		Compiler=>'VC32',
 		CPU=>'WINS',
-		MakeMod=>'Cl_win',
+		MakeMod=>'cl_win',
 		OS=>'WINS',
 	},
 	WINS=>{
@@ -175,7 +189,7 @@ my %Plat=(
 		ASSPABI=>'',
 		Compiler=>'VC32',
 		CPU=>'WINS',
-		MakeMod=>'Cl_win',
+		MakeMod=>'cl_win',
 		OS=>'WINS',
 	},
 	WINSCW=>{
@@ -183,22 +197,24 @@ my %Plat=(
 		ASSPABI=>'',
 		Compiler=>'CW32',
 		CPU=>'WINS',
-		MakeMod=>'Cl_codewarrior',
+		MakeMod=>'cl_codewarrior',
 		OS=>'WINS',
 		DefFile=>'WINS',	# use the MSVC def files
 	},
+	  #
+	  # added platform PDT for program analysis
+	  # Copy of ARMI with addition of MakeMod definition
+	  # We want it to masquerade as GCC....
+	  #
+	PDT=>{
+		ASSP=>'MARM',
+		Generic=>1,
+		MakeMod=>'cl_pdt',
+		ASSPABI=>'',
+	}
 
-# TO DO: (mandatory)
-#
-# Add here a definition for your port
-#
-	MTEMPLATE=>{
-		OS=>'EPOC32',
-		CPU=>'MARM',
-		MakeMod=>'Cl_gcc',
-		ABI=>'ARMI',
-		ASSPABI=>'ARM4'
-	},
+	# ASSP platforms should be described using .ASSP files
+	# Do not add additional ASSP platforms to this file.
 );
 
 sub Plat_Init ($) { # takes path to ASSP modules
@@ -213,13 +229,22 @@ sub Plat_Init ($) { # takes path to ASSP modules
 
 #	get a list of modules
 	opendir DIR, $Path;
-	my @ASSPs=grep s/^([^\.].*)\.ASSP$/$1/, map { uc $_ } readdir DIR;
+
+	my @ASSPs;
+	@files = readdir DIR;
+	foreach (@files) {
+	  if (m/^([^\.].*)\.assp$/) {
+	    push @ASSPs, uc $1;
+	  }
+	}
+	# alfredh: strangely enough this does not work on linux
+	#=grep s|^([^/.].*)\.assp$|$1|, map { uc $_ } readdir DIR;
 	closedir DIR;
 
 #	open each module in turn, and add it to the array
 	my $ASSP;
 	foreach $ASSP (@ASSPs) {
-		my $File=$Path.$ASSP.'.assp';
+		my $File= lc $Path.$ASSP.'.assp';
 #		check whether the assp is already defined
 		if (defined %{$Plat{$ASSP}}) {
 			warn(
@@ -277,7 +302,8 @@ sub Plat_Init ($) { # takes path to ASSP modules
 
 sub Plat_GetL ($$$) { # takes Platform name, ref to plat hash, ref to bldmacrohash
 	my ($Candidate,$PlatHash_ref,$BldMacrosHash_ref)=@_;
-	$Candidate=uc $Candidate;
+
+	$Candidate = uc $Candidate;
 
 # is platform in our list?
 	unless (defined $Plat{$Candidate}) {
@@ -295,7 +321,7 @@ sub Plat_GetL ($$$) { # takes Platform name, ref to plat hash, ref to bldmacroha
 
 	$PlatHash{Compiler}='GCC32' unless $PlatHash{Compiler};
 	$PlatHash{OS}='EPOC32' unless $PlatHash{OS};
-	$PlatHash{MakeMod}='Cl_gcc' unless $PlatHash{MakeMod};
+	$PlatHash{MakeMod}='cl_gcc' unless $PlatHash{MakeMod};
 	$PlatHash{CPU}='MARM' unless $PlatHash{CPU};
 	$PlatHash{Single}=0 unless $PlatHash{Single};
 	$PlatHash{UsrHdrsOnly}=0 unless $PlatHash{UsrHdrsOnly};
@@ -382,6 +408,8 @@ sub Plat_AssocIDE ($) {
 #	return the IDE associated with a "Real" platform if there is one
 	my ($Candidate)=@_;
 
+	$Candidate = uc $Candidate;
+
 	unless (defined $Plat{$Candidate}) {
 		die "ERROR: Platform \"$Candidate\" not supported\n";
 	}
diff --git a/e32tpver.pm b/e32tpver.pm
index 607a1ed..43a5d5b 100644
--- a/e32tpver.pm
+++ b/e32tpver.pm
@@ -6,7 +6,7 @@
 
 # Returns the version number for E32TOOLP - update for each release
 
-package E32tpver;
+package e32tpver;
 require Exporter;
 @ISA=qw(Exporter);
 @EXPORT=qw(
diff --git a/efreeze.pl b/efreeze.pl
index 665f5e6..4ce17dc 100644
--- a/efreeze.pl
+++ b/efreeze.pl
@@ -13,12 +13,11 @@ my $PerlLibPath;
 BEGIN {
 # check user has a version of perl that will cope and use DEFMAKE as specified by the system path
 	require 5.003_07;
-	foreach (split ';', $ENV{Path}) {
-		s-/-\\-go;	# for those working with UNIX shells
+	foreach (split ':', $ENV{PATH}) {
 		s-^$-.-o;	# convert empty string to .
-		s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-		if (-e $_.'EFREEZE.PL') {
-			$PerlLibPath=uc $_;
+		s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a backslash
+		if (-e $_.'efreeze.pl') {
+			$PerlLibPath=$_;
 			last;
 		}
 	}
@@ -28,9 +27,9 @@ BEGIN {
 use Getopt::Long;
 
 use lib $PerlLibPath;
-use Defutl;
-use E32tpver;
-use Pathutl;
+use defutl;
+use e32tpver;
+use pathutl;
 
 
 # THE MAIN PROGRAM SECTION
diff --git a/epoc b/epoc
new file mode 100644
index 0000000..7f7c19a
--- /dev/null
+++ b/epoc
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# epoc - bash interface for epoc.pl, part of GnuPoc project
+#
+# (c) 2002 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+perl -S epoc.pl "$@"
diff --git a/epoc.pl b/epoc.pl
index f3ef433..c8e1aef 100644
--- a/epoc.pl
+++ b/epoc.pl
@@ -1,3 +1,4 @@
+#!/usr/bin/perl -w
 #
 # Launcher for the Symbian Emulator, including
 # functionality to read the $ENV{EPOCROOT}epoc32\data\BuildInfo.txt
@@ -50,8 +51,8 @@ sub launchEmulator
     my $type = shift;
     my $epocroot = &getEpocroot;
     my $drive = &getDrive;
-    my $emu = $drive . $epocroot . "epoc32" . "\\" 
-	      . "release\\wins\\" . $type . "\\" . "epoc.exe";
+    my $emu = $drive . $epocroot . "epoc32" . "\/" 
+	      . "release\/wins\/" . $type . "\/" . "epoc.exe";
     -e $emu ||
 	die "ERROR: File \"$emu\" not found.\n\n" .
 	    "The EPOCROOT environment variable does not identify\n" .
@@ -60,7 +61,7 @@ sub launchEmulator
 		    "directory - it should have no drive qualifier and\n" .
 			"must end with a backslash.\n";
     # If the execute is successful, this never returns.
-    exec("\"" . $emu . "\"") || die "Failed to execute the emulator \"$emu\": $!";
+    exec("wine " . $emu) || die "Failed to execute the emulator \"$emu\": $!";
 }
 
 sub printHelp
@@ -78,8 +79,8 @@ sub printVersion
     my $epocroot = &getEpocroot;
     my $drive = &getDrive;
 
-    my $binfo = $drive . $epocroot . "epoc32" . "\\" 
-	        . "data" . "\\" . "BuildInfo.txt";
+    my $binfo = $drive . $epocroot . "epoc32" . "\/" 
+	        . "data" . "\/" . "buildinfo.txt";
 
     -e $binfo || die "ERROR: File \"" . $binfo . "\" does not exist.\n";
     open(IFILE, $binfo) ||
@@ -146,11 +147,9 @@ sub getEpocroot
     my $epocroot = $ENV{EPOCROOT};
     die "ERROR: Must set the EPOCROOT environment variable.\n"
 	if (!defined($epocroot));
-    $epocroot =~ s-/-\\-go;	# for those working with UNIX shells
     die "ERROR: EPOCROOT must be an absolute path, " .
-	"not containing a drive letter.\n" if ($epocroot !~ /^\\/);
+	"not containing a drive letter.\n" if ($epocroot !~ /^\//);
     die "ERROR: EPOCROOT must not be a UNC path.\n" if ($epocroot =~ /^\\\\/);
-    die "ERROR: EPOCROOT must end with a backslash.\n" if ($epocroot !~ /\\$/);
     die "ERROR: EPOCROOT must specify an existing directory.\n" 
 	if (!-d $epocroot);
     return $epocroot;
diff --git a/epocaif.pl b/epocaif.pl
index 5f1155e..b5c75b1 100644
--- a/epocaif.pl
+++ b/epocaif.pl
@@ -18,22 +18,19 @@ BEGIN {
 	require 5.005_03;
 # establish the path to the Perl binaries
 	$PerlBinPath = $FindBin::Bin;	# X:/epoc32/tools
-	$PerlBinPath =~ s/\//\\/g;	# X:\epoc32\tools
-	use lib $PerlBinPath;
+#	use lib $PerlBinPath;
 }
 
 my $uppath="x";	    # will be initialised when first needed
 
 my $epocroot = $ENV{EPOCROOT};
 die "ERROR: Must set the EPOCROOT environment variable\n" if (!defined($epocroot));
-$epocroot =~ s-/-\\-go;	# for those working with UNIX shells
 die "ERROR: EPOCROOT must not include a drive letter\n" if ($epocroot =~ /^.:/);
-die "ERROR: EPOCROOT must be an absolute path without a drive letter\n" if ($epocroot !~ /^\\/);
-die "ERROR: EPOCROOT must not be a UNC path\n" if ($epocroot =~ /^\\\\/);
-die "ERROR: EPOCROOT must end with a backslash\n" if ($epocroot !~ /\\$/);
+die "ERROR: EPOCROOT must be an absolute path without a drive letter\n" if ($epocroot !~ /^\//);
+die "ERROR: EPOCROOT must end with a forward slash\n" if ($epocroot !~ /\/$/);
 die "ERROR: EPOCROOT must specify an existing directory\n" if (!-d $epocroot);
 
-$epocroot=~ s-\\$--;		# chop trailing \\
+$epocroot=~ s-\/$--;		# chop trailing /
 
 
 sub print_usage
@@ -50,7 +47,7 @@ The available options are
    -Ixxx  -- C++ preprocessor arguments
    -o	  -- output AIF file name including path
    -t	  -- tempory directory for intermediate files
-   -b	  -- list of bitmaps Eg., "-b/c8\\location\\bmp1 /c8\\location\\bmp2.."
+   -b	  -- list of bitmaps Eg., "-b/c8\/location\/bmp1 /c8\/location\/bmp2.."
    -m	  -- compiled MBM file (alternative to -b)
 
 The aif resource file is then passed through the C++ preprocessor, using any 
@@ -78,7 +75,7 @@ my $opt_l="";
 my $opt_m="";
 my $TrgPath;
 
-my $cpp_spec= "cpp -undef -C ";	    # preserve comments
+my $cpp_spec= "arm-epoc-pe-cpp -undef -C ";	    # preserve comments
 
 my $errors = 0;
 while (@ARGV)
@@ -111,7 +108,7 @@ while (@ARGV)
 		next;
 		}
 
-	if ($arg =~ /^-t(.*)\\?$/)
+	if ($arg =~ /^-t(.*)\/?$/)
 		{
 		$tmpdir =$1;
 		next;
@@ -146,7 +143,6 @@ if ($opt_m ne "" && $opt_b ne "")
 	print "Can't specify both -m and -b\n";
 	$errors++;
 	}
-
 if ($errors || $sourcefile eq "")
 	{
 	print_usage();
@@ -155,8 +151,8 @@ if ($errors || $sourcefile eq "")
 
 my $rss_base = basename($sourcefile);
 my ($rssfile) = split(/\./, $rss_base);	    # remove extension
-my $rpp_name = "$tmpdir\\$rssfile.rpp";
-my $outputfile="$tmpdir\\AIF.RSC";	
+my $rpp_name = "$tmpdir\/$rssfile.rpp";
+my $outputfile="$tmpdir\/aif.rsc";	
 my $headerfile=$opt_h;
 
 if ($opt_v)
@@ -173,7 +169,7 @@ $opt_h = "-h\"$headerfile\"" if ($headerfile ne "");
 # Run the preprocessor
 #
 
-$cpp_spec .= "-I $PerlBinPath\\..\\include ";	# extra path to support shared tools
+$cpp_spec .= "-I $PerlBinPath\/..\/include ";	# extra path to support shared tools
 $cpp_spec .= "-D_UNICODE ";
 $cpp_spec .= "<\"$sourcefile\"";
 
@@ -195,7 +191,8 @@ die "* cpp failed\n" if ($cpp_status != 0);
 # Run the resource compiler
 #
 
-my $rcomp_spec = "rcomp -u ";
+#my $rcomp_spec = "wine $epocroot/epoc32/tools/rcomp.exe -u ";
+my $rcomp_spec = "rcomp -6 -u ";
 $rcomp_spec .= "$opt_o $opt_h -s\"$rpp_name\" -i\"$sourcefile\"";
 
 print "* $rcomp_spec\n" if ($opt_v);
@@ -216,18 +213,20 @@ unlink $rpp_name;
 
 if ($opt_b ne "")
 	{
-	print "* bmconv /q $tmpdir\\AIF.MBM $opt_b\n" if ($opt_v);
-	system("bmconv /q $tmpdir\\AIF.MBM $opt_b");
+        my $outdir = $tmpdir;
+        $outdir = "/.$outdir" if ($outdir =~ /^\//); # fix the case when $outdir is /home/...
+	print "* bmconv /q $outdir\/aif.mbm $opt_b\n" if ($opt_v);
+	system("bmconv /q $outdir\/aif.mbm $opt_b");
 	}
 elsif ($opt_m ne "")
 	{
-	print "* copy $opt_m $tmpdir\\AIF.MBM\n" if ($opt_v); 
-	copy($opt_m, "$tmpdir\\AIF.MBM"); 
+	print "* cp $opt_m $tmpdir\/aif.mbm\n" if ($opt_v); 
+	copy($opt_m, "$tmpdir\/aif.mbm"); 
 	}
 else
 	{
 	# no bitmap specified - this is legitimate
-	unlink("$tmpdir\\AIF.MBM");
+	unlink("$tmpdir\/aif.mbm");
 	}
 
 #-------------------------------------------------------
@@ -236,21 +235,26 @@ else
 #
 
 $PerlBinPath =~ /^(.*)\\/;
-my $aiftool = "$1\\release\\winc\\urel\\aiftool.exe";
-print "* $aiftool $tmpdir\\ \n" if ($opt_v);
-system("$aiftool $tmpdir\\");
+my $aiftool = "aiftool";
+my $which = `which aiftool`;
+if ($which =~ /epoc32/ || $which eq "") {
+	$aiftool = "wine $epocroot/epoc32/release/winc/urel/aiftool.exe";
+}
+
+print "* $aiftool $tmpdir/ \n" if ($opt_v);
+system("$aiftool $tmpdir/");
 if ($? != 0)
 	{
 	print "* AIFTOOL failed\n";
 	exit 1;
 	}
 
-print "* copy $tmpdir\\out.aif $TrgPath\n" if ($opt_v);
-copy("$tmpdir\\out.aif", "$TrgPath");
+print "* cp $tmpdir\/out.aif $TrgPath\n" if ($opt_v);
+copy("$tmpdir\/out.aif", "$TrgPath");
 
-unlink("$tmpdir\\aif.rsc");
-unlink("$tmpdir\\aif.mbm");
-unlink("$tmpdir\\out.aif");
+unlink("$tmpdir\/aif.rsc");
+unlink("$tmpdir\/aif.mbm");
+unlink("$tmpdir\/out.aif");
 exit 0;
 
 #-------------------------------------------------------
@@ -260,7 +264,7 @@ exit 0;
 sub quoted_relative_path
     {
     my ($arg) = @_;
-    return "\"$arg\"" if ($arg !~ /^\\/);	# not an absolute path
+    return "\"$arg\"" if ($arg !~ /^\//);	# not an absolute path
     if ($uppath eq "x")
 	{
 	$uppath=cwd;
diff --git a/epocrc.pl b/epocrc.pl
index 2b8f5da..0af82d0 100644
--- a/epocrc.pl
+++ b/epocrc.pl
@@ -1,3 +1,5 @@
+#!/usr/bin/perl -w
+#
 # epocrc.pl
 #
 # Copyright (c) 2000 Symbian Ltd.  All rights reserved.
@@ -11,14 +13,11 @@ my $uppath="x";	    # will be initialised when first needed
 
 my $epocroot = $ENV{EPOCROOT};
 die "ERROR: Must set the EPOCROOT environment variable\n" if (!defined($epocroot));
-$epocroot =~ s-/-\\-go;	# for those working with UNIX shells
-die "ERROR: EPOCROOT must not include a drive letter\n" if ($epocroot =~ /^.:/);
-die "ERROR: EPOCROOT must be an absolute path without a drive letter\n" if ($epocroot !~ /^\\/);
-die "ERROR: EPOCROOT must not be a UNC path\n" if ($epocroot =~ /^\\\\/);
-die "ERROR: EPOCROOT must end with a backslash\n" if ($epocroot !~ /\\$/);
+die "ERROR: EPOCROOT must be an absolute path\n" if ($epocroot !~ /^\//);
+die "ERROR: EPOCROOT must end with a forward slash\n" if ($epocroot !~ /\/$/);
 die "ERROR: EPOCROOT must specify an existing directory\n" if (!-d $epocroot);
 
-$epocroot=~ s-\\$--;		# chop trailing \\
+$epocroot=~ s-\/$--;		# chop trailing slash
 
 sub print_usage
 	{
@@ -58,7 +57,7 @@ my $tmpdir="";
 my $unicode=0;
 my $opt_v=0;
 
-my $cpp_spec= "cpp -undef -C ";	    # preserve comments
+my $cpp_spec= "arm-epoc-pe-cpp -undef ";	    # preserve comments
 
 my $errors = 0;
 while (@ARGV)
@@ -113,7 +112,7 @@ while (@ARGV)
 		}
 	if ($arg =~ /^-t(.*)\\?$/)
 		{
-		$tmpdir ="$1\\";
+		$tmpdir ="$1\/";
 		next;
 		}
 	if ($arg =~ /^-/)
@@ -171,20 +170,17 @@ die "* cpp failed\n" if ($cpp_status != 0);
 
 
 #-------------------------------------------------------
-# Copy rpp files to epoc32\localisation
+# Copy rpp files to epoc32/localisation
 #
 
 my $outfile = basename($outputfile);
 chomp($outfile);
 
-if($outfile ne "AIF.RSC")
+if($outfile ne "aif.rsc")
 	{
-	if (-e "$epocroot\\epoc32\\localisation\\$rssfile.rpp") 
-		{
-		unlink("$epocroot\\epoc32\\localisation\\$rssfile.rpp");
-		}
-	print "* copy $rpp_name $epocroot\\epoc32\\localisation\\$rssfile.rpp\n" if ($opt_v);
-	system("copy $rpp_name $epocroot\\epoc32\\localisation\\$rssfile.rpp");
+	system("mkdir -p $epocroot\/epoc32\/localisation");
+	print "* cp -f $rpp_name $epocroot\/epoc32\/localisation\/$rssfile.rpp\n" if ($opt_v);
+	system("cp -f $rpp_name $epocroot\/epoc32\/localisation\/$rssfile.rpp");
 	}
 
 
@@ -192,9 +188,10 @@ if($outfile ne "AIF.RSC")
 # Run the resource compiler
 #
 
-my $rcomp_spec = "rcomp ";
+
+my $rcomp_spec = "rcomp -6 ";
 $rcomp_spec .= "-u " if ($unicode);
-$rcomp_spec .= "$opt_o $opt_h -s\"$rpp_name\" -i\"$sourcefile\"";
+$rcomp_spec .= " $opt_o $opt_h -s$rpp_name -i$sourcefile";
 
 print "* $rcomp_spec\n" if ($opt_v);
 system($rcomp_spec);
diff --git a/eshell b/eshell
new file mode 100644
index 0000000..162482b
--- /dev/null
+++ b/eshell
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# eshell - bash interface for eshell.pl, part of GnuPoc project
+#
+# (c) 2002 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+perl -S eshell.pl "$@"
diff --git a/eshell.pl b/eshell.pl
index 113a7b8..cfb8d52 100644
--- a/eshell.pl
+++ b/eshell.pl
@@ -1,3 +1,4 @@
+#!/usr/bin/perl -w
 #
 # Eshell Launcher
 #
@@ -43,8 +44,8 @@ sub launchEshell
     my $type = shift;
     $epocroot = &getEpocroot;
     $drive = &getDrive;
-    $emu = $drive . $epocroot . "epoc32" . "\\" 
-	. "release\\wins\\" . $type . "\\" . "eshell.exe";
+    $emu = $drive . $epocroot . "epoc32" . "\/" 
+	. "release\/wins\/" . $type . "\/" . "eshell.exe";
     -e $emu ||
 	die "ERROR: File \"$emu\" not found.\n\n" .
 	    "The EPOCROOT environment variable does not identify\n" .
@@ -57,7 +58,7 @@ sub launchEshell
 	$emu.=" -MConsole --";
 			
     # If the execute is successful, this never returns.
-    exec($emu) || die "Failed to execute eshell \"$emu\": $!";
+    exec("wine " . $emu) || die "Failed to execute eshell \"$emu\": $!";
 }
 
 sub printHelp
@@ -77,11 +78,9 @@ sub getEpocroot
     my $epocroot = $ENV{EPOCROOT};
     die "ERROR: Must set the EPOCROOT environment variable.\n"
 	if (!defined($epocroot));
-    $epocroot =~ s-/-\\-go;	# for those working with UNIX shells
     die "ERROR: EPOCROOT must be an absolute path, " .
-	"not containing a drive letter.\n" if ($epocroot !~ /^\\/);
     die "ERROR: EPOCROOT must not be a UNC path.\n" if ($epocroot =~ /^\\\\/);
-    die "ERROR: EPOCROOT must end with a backslash.\n" if ($epocroot !~ /\\$/);
+    die "ERROR: EPOCROOT must end with a forward slash.\n" if ($epocroot !~ /\/$/);
     die "ERROR: EPOCROOT must specify an existing directory.\n" 
 	if (!-d $epocroot);
     return $epocroot;
diff --git a/fixupsym.pl b/fixupsym.pl
index 704499d..13a730c 100644
--- a/fixupsym.pl
+++ b/fixupsym.pl
@@ -340,7 +340,7 @@ sub help ()
   {
 	my $build;
 	
-	&Load_ModuleL('E32TPVER');
+	&Load_ModuleL('e32tpver');
 	print "\nfixupsym - " .
 	  "Fix up executables with locations taken from a ROM image (Build ",
 	  &E32tpver, ")\n";
diff --git a/genbldinf.pl b/genbldinf.pl
new file mode 100644
index 0000000..242f56d
--- /dev/null
+++ b/genbldinf.pl
@@ -0,0 +1,38 @@
+#!/usr/bin/perl -w
+#
+# genbldinf.pl - part of GnuPoc project
+#
+# Recursively generate a bld.inf file from a given subsystem
+#
+# (c) 2001 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+my $BLDINF = "bld.inf";
+
+print "OS: $^O\n";
+
+unlink $BLDINF if (-f $BLDINF);
+
+$_ = `find . -iname $BLDINF`;
+
+s/(.*bld.inf.*)/\#include "$1"/igm;
+
+if ($^O eq "MSWin32") {
+  print "win32 hack:\n";
+  s|/|\\|gm;
+  $_ = lc $_;
+}
+
+open FO, ">$BLDINF" or die "Could not create $BLDINF";
+print FO "//\n";
+print FO "// bld.inf - generated by 'genbldinf.pl' - part of GnuPoc project\n";
+print FO "//\n";
+print FO $_;
+close FO;
+
+print "creating $BLDINF with:\n";
+system ("cat $BLDINF");
diff --git a/genutl.pm b/genutl.pm
index 671fb5e..8a6b7a4 100644
--- a/genutl.pm
+++ b/genutl.pm
@@ -6,7 +6,7 @@
 
 # Contains utility subroutines for MAKMAKE and associated scripts
 
-package Genutl;
+package genutl;
 
 require Exporter;
 @ISA=qw(Exporter);
diff --git a/hpsym.pl b/hpsym.pl
index 010b33a..51008c5 100644
--- a/hpsym.pl
+++ b/hpsym.pl
@@ -163,7 +163,7 @@ sub help ()
   {
 	my $build;
 
-	&Load_ModuleL('E32TPVER');
+	&Load_ModuleL('e32tpver');
 	print "\nhpsym - Produce symbolic info in \"HP GPA Symbol File Format\"" .
 	  " suitable for use\n        with a HP logic analyser (Build ",
 	  &E32tpver, ")\n";
diff --git a/ide_vc6.pm b/ide_vc6.pm
index fff92a5..3b349fa 100644
--- a/ide_vc6.pm
+++ b/ide_vc6.pm
@@ -882,7 +882,8 @@ sub PMResrcDepend {
 			foreach (@ChopRTMSysIncPaths) {
 				$SupText.=" -I \"$_\"";
 			}
-			$SupText.=" -DLANGUAGE_$Lang -u \"$RTMSrcPath$Resrc\"";
+			my $uclang = uc $Lang;
+			$SupText.=" -DLANGUAGE_$uclang -u \"$RTMSrcPath$Resrc\"";
 			$SupText.=" -o\"$ResrcTrgFullName$Lang\" -h\"$RTMSrcPath$BaseResrc.rs~\" -t\"\$(EPOCBLD$Bld)\"\n";
 # 			hack because if a .RSC file is output then VC5 tries to link it to the main target as a Win32 resource file
 			if ($Lang eq 'SC') {
diff --git a/makdeps.pm b/makdeps.pm
index 4b751ce..097b3e5 100644
--- a/makdeps.pm
+++ b/makdeps.pm
@@ -1,13 +1,13 @@
 # MAKDEPS.PM
 #
-# Copyright (c) 1997-1999 Symbian Ltd.  All rights reserved.
+# Copyright (c) 1997-2001 Symbian Ltd.  All rights reserved.
 #
 
 
 # Module which wraps the dependency information provided the preprocessor when invoked with certain switches
 # so that dependency information rather than preprocessing information is produced.
 
-package Makdeps;
+package makdeps;
 require Exporter;
 @ISA=qw(Exporter);
 @EXPORT=qw(
@@ -21,8 +21,8 @@ require Exporter;
 	Deps_GenDependsL
 );
 
-use Checkgcc;
-use Pathutl;
+use checkgcc;
+use pathutl;
 
 my $ChopSysDecoyPath;
 my $EPOCIncPath;
@@ -48,8 +48,7 @@ BEGIN {	# NB don't initialise essential items to be provided later by calling mo
 	@StdPaths=();
 	@SysFlags=();
 	@UserFlags=();
-	$S_SysDecoyPath=$SysDecoyPath=&Path_WorkPath."TEMPMAKSYSDECOY\\";
-	$S_SysDecoyPath=~s-\\-\\\\-go;
+	$S_SysDecoyPath=$SysDecoyPath=&Path_WorkPath."TEMPMAKSYSDECOY/";
 	$ChopSysDecoyPath=&Path_Chop($SysDecoyPath);
 }
 
@@ -62,7 +61,7 @@ sub Deps_InitL ($@) {	# abs Generated Hdr dir, StdIncsysdir (with drive letter i
 # work and the user will have to sort it out.  If it doesn't contain files and has been left lying around
 # because someone has killed the program half-way through, then rmdir will remove it and mkdir will work OK
 	rmdir $ChopSysDecoyPath if -d $ChopSysDecoyPath;
-	mkdir $ChopSysDecoyPath,2 or die "ERROR: Can't make temp dir \"$ChopSysDecoyPath\"\nIf it already exists, please remove it\n";
+	mkdir $ChopSysDecoyPath or die "ERROR: Can't make temp dir \"$ChopSysDecoyPath\"\nIf it already exists, please remove it\n";
 }
 sub Deps_SetVerbose {
 	$Mode{'Verbose'}=1;
@@ -79,7 +78,7 @@ sub Deps_SetSysIncPaths (@) {	# takes list abs paths
 	@SysFlags=&Path_Chop(&Path_RltToWork(@SysPaths)); # newer gcc doesn't like trailing backslash
 	my $Flag;
 	foreach $Flag (@SysFlags) {
-		$Flag=~s/^(.*)$/-I "$1"/o;
+		$Flag=~s/^(.*)$/-I "$1"/o if $Flag;
 	}
 }
 sub Deps_SetUserIncPaths (@) {	# takes list of abs paths
@@ -99,6 +98,7 @@ sub Deps_SetPlatMacros (@) {
 	my $Flag;
 	foreach $Flag (@PlatMacros) {
 		$Flag=~s/^(.*)$/-D$1/o;
+		$Flag = uc $Flag; # force uppercase for macros
 	}
 }
 
@@ -129,12 +129,11 @@ sub Deps_GenDependsL ($@) {	# takes abs source filepath and list of Build Macros
 
 	my $RTWSrcPath=&Path_Chop(&Path_Split('Path',$RTWSrc)); # newer gcc doesn't like trailing backslash
 	if ($Mode{'Verbose'}) {
-		print "CPP.EXE -M -MG -nostdinc -I \"$RTWSrcPath\" @UserFlags -I- @SysFlags @PlatMacros @BldMacros \"$RTWSrc\"\n";
+		print "arm-epoc-pe-cpp -M -MG -nostdinc -I \"$RTWSrcPath\" @UserFlags -I- @SysFlags @PlatMacros @BldMacros \"$RTWSrc\"\n";
 	}
-	open CPPPIPE,"CPP.EXE -M -MG -nostdinc -I \"$RTWSrcPath\" @UserFlags -I- -I \"$RTWSysDecoyPath\" @SysFlags @PlatMacros @BldMacros \"$RTWSrc\" |" or die "ERROR: Can't invoke CPP.EXE\n";
+	open CPPPIPE,"arm-epoc-pe-cpp -M -MG -nostdinc -I \"$RTWSrcPath\" @UserFlags -I- -I \"$RTWSysDecoyPath\" @SysFlags @PlatMacros @BldMacros \"$RTWSrc\" |" or die "ERROR: Can't invoke CPP\n";
 	my @RTWDepList;
 	while (<CPPPIPE>) {
-		$_ = uc $_;
 		while (/\s(\S\S+)/go) {
 			# preprocessor will crash here if spaces in long filenames - but can search for \<space> for spaces in filenames
 			# or will be able to with new gcc build perhaps
@@ -142,14 +141,14 @@ sub Deps_GenDependsL ($@) {	# takes abs source filepath and list of Build Macros
 			push @RTWDepList,$1;
 		}
 	}
-	close CPPPIPE or die "ERROR: CPP.EXE failure\n";
+	close CPPPIPE or die "ERROR: CPP failure\n";
 
 	# drop the second element of preprocessor's output
 	shift @RTWDepList;
 
 	foreach (@RTWDepList) {
 	# replace its forward slashes with backward slashes
-		s-/-\\-go;
+		s-/-\/-go;
 	}
 
 # make all paths absolute
@@ -208,7 +207,7 @@ sub TestDepends (@) { # takes source list of absolute dependencies - called by G
 # any files listed as existing in the system decoy directory will be missing system include files
 			$File=$1;
 # change any missing generated header entries so that they are thought to be in $EPOCIncPath, where they will be generated to
-			if ($File=~/\.(RSG|MBG)$/o) {
+			if ($File=~/\.(rsg|mbg)$/o) {
 				push @GoodList, "$EPOCIncPath$File";
 				next DEPLOOP;
 			}
@@ -271,7 +270,7 @@ sub TestDepends (@) { # takes source list of absolute dependencies - called by G
 		my $GenHdr=0;
 		foreach $Bad (@BadUserList) {
 			print STDERR " \"$Bad\"";
-			if ($File=~/\.(RSG|MBG)$/o) {
+			if ($File=~/\.(rsg|mbg)$/o) {
 				$GenHdr=1;
 			}
 		}
diff --git a/makedef.pl b/makedef.pl
index b7c88c7..9688735 100644
--- a/makedef.pl
+++ b/makedef.pl
@@ -13,12 +13,11 @@ my $PerlLibPath;
 BEGIN {
 # check user has a version of perl that will cope and use MAKEDEF as specified by the system path
 	require 5.003_07;
-	foreach (split ';', $ENV{Path}) {
-		s-/-\\-go;	# for those working with UNIX shells
+	foreach (split ':', $ENV{PATH}) {
 		s-^$-.-o;	# convert empty string to .
-		s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-		if (-e $_.'MAKEDEF.PL') {
-			$PerlLibPath=uc $_;
+		s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a backslash
+		if (-e $_.'makedef.pl') {
+			$PerlLibPath=$_;
 			last;
 		}
 	}
@@ -28,9 +27,9 @@ BEGIN {
 use Getopt::Long;
 
 use lib $PerlLibPath;
-use Defutl;
-use E32tpver;
-use Pathutl;
+use defutl;
+use e32tpver;
+use pathutl;
 use File::Copy;
 
 # THE MAIN PROGRAM SECTION
@@ -190,6 +189,7 @@ sub ReadInfFileL ($$$) {
 	my $LineNum=0;
 	my $Ordinal=0;
 	while (<FILE>) {
+		$_ =~ s/\r$//;
 		$LineNum++;
 		if (/^\s+(\?\S+)(\s+\((.*)\))?$/o) {
 			$Ordinal++;
diff --git a/makesis b/makesis
new file mode 100644
index 0000000..cb51054
--- /dev/null
+++ b/makesis
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# makesis - bash frontend for makesis.exe, part of GnuPoc project
+#
+# (c) 2001 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+PGM=`basename $0`
+echo "executing $PGM.exe"
+ROOT=$EPOCROOT/epoc32/tools
+wine $ROOT/$PGM.exe "$@"
diff --git a/makhelp.pm b/makhelp.pm
index 35037c4..aa6ae35 100644
--- a/makhelp.pm
+++ b/makhelp.pm
@@ -4,7 +4,7 @@
 #
 
 
-package Makhelp;
+package makhelp;
 require Exporter;
 @ISA=qw(Exporter);
 @EXPORT=qw(
@@ -14,7 +14,7 @@ require Exporter;
 );
 
 
-use E32tpver;
+use e32tpver;
 # also requires main module to have loaded platform module(s) and Modload.pm and Trgtype.pm
 
 sub Help_Invocation () {
@@ -26,7 +26,7 @@ sub Help_Invocation () {
 		"MAKMAKE {flags} [{MMPFilePath}MMPFileRoot] [Platform]\n",
 		"\n",
 		"Flags: (case insensitive)\n",
-		" -D               -> create makefile in ", $E32env::Data{BldPath}, "[project]\\[platform]\\\n",
+		" -D               -> create makefile in ", $e32env::Data{BldPath}, "[project]\\[platform]\\\n",
 		" -MMP             -> information - basic mmp syntax\n",
 		" -PLAT [platform] -> information - platform-specific mmp syntax\n",
 		" -V               -> verbose mode\n",
@@ -75,7 +75,7 @@ ASSPABI
 ASSPEXPORTS
 ASSPLIBRARY            [ASSP_libraries]
 DEFFILE                [{path}{deffile} (default -
-                          \[project]\B[platform]\[target basename].DEF)]
+                          \[project]B[platform]\[target basename].DEF)]
 DOCUMENT               [sourcepath-relative_documents]
 EPOCALLOWDLLDATA
 EPOCCALLDLLENTRYPOINTS
diff --git a/makmake b/makmake
new file mode 100644
index 0000000..9199434
--- /dev/null
+++ b/makmake
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# makmake - bash frontend for makmake.pl, part of GnuPoc project
+#
+# (c) 2001-2002 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+perl -S makmake.pl "$@"
diff --git a/makmake.pl b/makmake.pl
index b9af23a..0be186b 100644
--- a/makmake.pl
+++ b/makmake.pl
@@ -1,3 +1,5 @@
+#!/usr/bin/perl -w
+#
 # MAKMAKE.PL
 #
 # Copyright (c) 1997-1999 Symbian Ltd.  All rights reserved.
@@ -13,12 +15,11 @@ my $PerlLibPath;
 BEGIN {
 # check user has a version of perl that will cope and use makmake as specified by the system path
 	require 5.003_07;
-	foreach (split ';', $ENV{Path}) {
-		s-/-\\-go;	# for those working with UNIX shells
+	foreach (split ':', $ENV{PATH}) {
 		s-^$-.-o;	# convert empty string to .
-		s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-		if (-e $_.'MAKMAKE.PL') {
-			$PerlLibPath=uc $_;
+		s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a backslash
+		if (-e $_.'makmake.pl') {
+			$PerlLibPath=$_;
 			last;
 		}
 	}
@@ -28,12 +29,12 @@ BEGIN {
 use Getopt::Long;
 
 use lib $PerlLibPath;
-use E32env;
-use E32Plat;
-use Genutl;
-use Modload;
-use Pathutl;
-use Trgtype;
+use e32env;
+use e32plat;
+use genutl;
+use modload;
+use pathutl;
+use trgtype;
 
 
 # THE MAIN PROGRAM SECTION
@@ -59,7 +60,7 @@ my %Plat;
 	$Options{makemakefile}='1' unless ($Options{mmp} || $Options{plat});
 
 	if ($Options{mmp} or $Options{plat}) {
-		eval { &Load_ModuleL('MAKHELP'); };
+		eval { &Load_ModuleL('makhelp'); };
 		die $@ if $@;
 	}
 
@@ -94,21 +95,21 @@ my %Plat;
 	eval { &Plat_GetL($Plat,\%Plat,\%BldMacros); };
 	die $@ if $@;
 
-	$MMPFILE=uc pop @ARGV;
+	$MMPFILE=pop @ARGV;
 	die "ERROR: Can't specify MMP file on a different drive\n" if $MMPFILE=~/^\w:\\/o;
 	if ($MMPFILE!~/.MMP$/o) {
-		$MMPFILE.='.MMP';
+		$MMPFILE.='.mmp';
 	}
 	$MMPFILE=&Path_AbsToWork($MMPFILE);
 
 	# MMP FILE PROCESSING - filter the mmp file content through the GCC preprecessor
 	#-------------------------------------------------------------------------------
-	eval { &Load_ModuleL('Mmp'); };
+	eval { &Load_ModuleL('mmp'); };
 	die $@ if $@;
 	if ($Options{v}) {
 		&Mmp_SetVerbose;
 	}
-	eval { &Mmp_ProcessL($E32env::Data{EPOCPath}, $MMPFILE, \%Plat); };
+	eval { &Mmp_ProcessL($e32env::Data{EPOCPath}, $MMPFILE, \%Plat); };
 	die $@ if $@;
 }
 
@@ -171,35 +172,36 @@ my %Path;
 {
 
 #	set up ASSP link path - this is the path where the target looks for ASSP-specific import libraries
-	$Path{ASSPLink}="$E32env::Data{LinkPath}$Plat{ASSP}\\";
+	$Path{ASSPLink}="$e32env::Data{LinkPath}" . lc $Plat{ASSP} . "\/";
 
 #	set up build path
-	$Path{Bld}=join('', &Path_Chop($E32env::Data{BldPath}), &Path_Split('Path',$MMPFILE), &Path_Split('Base',$MMPFILE), "\\$Plat{Real}\\");
+	$Path{Bld}=join('', &Path_Chop($e32env::Data{BldPath}), &Path_Split('Path',$MMPFILE), &Path_Split('Base',$MMPFILE), "\/", lc $Plat{Real}, "\/");
 
 #	set up lib path - this is the path where the target puts it's import library
-	$Path{Lib}="$E32env::Data{LinkPath}";
+	$Path{Lib}="$e32env::Data{LinkPath}";
 	unless ($ASSPExports) {
-		$Path{Lib}.="$ABI\\";
+		$Path{Lib}.= lc "$ABI\/"; # alfredh: ARM4->arm4, ARMI->armi
 	}
 	else {
-		$Path{Lib}.="$Plat{ASSP}\\";
+		$Path{Lib}.= lc "$Plat{ASSP}\/";
 	}
 
 #	set up link path - this is the place where the target looks for ordinary libraries
-	$Path{Link}="$E32env::Data{LinkPath}$ABI\\";
+	$Path{Link}="$e32env::Data{LinkPath}". lc $ABI . "\/";
 
 #	set up stat link path - this is where the target looks for static libraries
-	$Path{StatLink}="$E32env::Data{LinkPath}";
+	$Path{StatLink}="$e32env::Data{LinkPath}";
 	unless ($Plat{OS} eq 'WINS') {	# WINC and WINS versions of EEXE are different
-		$Path{StatLink}.="$ABI\\"; # ARM static libraries are currently always ASSP-independent
+		$Path{StatLink}.= lc "$ABI\/"; # ARM static libraries are currently always ASSP-independent
 	}
 	else {
-		$Path{StatLink}.="$Plat{ASSP}\\"; # WINC static libraries are currently always ASSP-specific
+		$Path{StatLink}.= lc "$Plat{ASSP}\/"; # WINC static libraries are currently always ASSP-specific
 	}
 
 #	set up release path
 	unless ($TrgType{Basic} eq 'LIB') {
-		$Path{Rel}="$E32env::Data{RelPath}$Plat{Real}\\";
+		$Path{Rel}="$e32env::Data{RelPath}";
+		$Path{Rel}.= lc "$Plat{Real}\/";
 	}
 	else {
 		$Path{Rel}=$Path{StatLink}; # static libraries can't #define the __SINGLE__ macro
@@ -210,10 +212,10 @@ my %Path;
 	# set up the makefile filepath - need to do this before loading the platform module
 	# because UID source file will be added and set up in the makefile path under WINS
 	if ($Options{d}) {
-		$MAKEFILE=join ('', $Path{Bld}, &Path_Split('Base',$MMPFILE), $Plat{Ext});
+		$MAKEFILE=join ('', $Path{Bld}, &Path_Split('Base',$MMPFILE), lc $Plat{Ext});
 	}
 	else {
-		$MAKEFILE=join "", &Path_WorkPath, &Path_Split('Base',$MMPFILE), $Plat{Ext};
+		$MAKEFILE=join "", &Path_WorkPath, &Path_Split('Base',$MMPFILE), lc $Plat{Ext};
 	}
 }
 
@@ -250,7 +252,7 @@ my @StdIncPaths=();
 	# if verbose mode set, output some info
 	#--------------------------------------
 	if ($Options{v}) {
-		print  
+		print
 			"Target: \"$Trg\"\n",
 			"TargetType: \"$TrgType{Name}\"\n",
 			"Libraries: \"@LibList\"\n",
@@ -282,7 +284,7 @@ my $ResrcIsSys;
 	# LOOPING SECTION
 	#----------------
 # Load the output module
-	eval { &Load_ModuleL('OUTPUT'); };
+	eval { &Load_ModuleL('output'); };
 	die $@ if $@;
 
 	&PMStartBldList if defined &PMStartBldList;
@@ -297,9 +299,9 @@ my $ResrcIsSys;
 
 
 	# Load the Dependency Generator
-	eval { &Load_ModuleL('MAKDEPS'); };
+	eval { &Load_ModuleL('makdeps'); };
 	die $@ if $@;
-	eval { &Deps_InitL($E32env::Data{EPOCIncPath},@StdIncPaths); };
+	eval { &Deps_InitL($e32env::Data{EPOCIncPath},@StdIncPaths); };
 	die $@ if $@;
 	if ($Options{v}) {
 		&Deps_SetVerbose;
@@ -367,7 +369,8 @@ my $ResrcIsSys;
 				my $lang;
 				foreach $lang (@LangList) {
 					my @depList;
-					eval { @depList=&Deps_GenDependsL($CurSrcPath.$CurResrc, ("LANGUAGE_$lang")); };
+					my $uclang = uc $lang;
+					eval { @depList=&Deps_GenDependsL($CurSrcPath.$CurResrc, ("LANGUAGE_$uclang")); };
 					die $@ if $@;
 					foreach (@depList) {
 						if (!exists $combinedDepList{$_}) {
@@ -459,11 +462,9 @@ my $ResrcIsSys;
 
 # Add tools-relative include path to sys includes, to allow for shared include\aiftool.rh
 	use FindBin;
-	$FindBin::Bin =~ /:(.*)\//;
-	my $extraIncPath = $1;
-	$extraIncPath =~ s/\//\\/g;
+	my $extraIncPath = $FindBin::Bin;
 	my @SavedSysIncPaths = @SysIncPaths;
-	push @SysIncPaths, "$extraIncPath\\INCLUDE";
+	push @SysIncPaths, "$extraIncPath\/include";
 	&Deps_SetSysIncPaths(@SysIncPaths);
 
 	my $LoopAifRef;
@@ -603,16 +604,16 @@ my $ResrcIsSys;
 			}
 #			$RomFileType='primary[MAGIC]' if $Trg eq 'EKERN.EXE';
 #			$RomFileType='secondary[MAGIC]' if $Trg eq 'EFILE.EXE';
-			my $RomPath="System\\Libs\\";
+			my $RomPath="System\/Libs\/";
 			if ($$ref{Path}) {
 				$RomPath=$$ref{Path};
 			}
 			elsif ($TrgType{Path}) {
 				$RomPath=$TrgType{Path};
-				$RomPath=~s-Z\\(.*)-$1-o;
+				$RomPath=~s-Z\/(.*)-$1-o;
 			}
 			elsif ($TrgType{Name} eq 'EXE') {
-				$RomPath="Test\\";
+				$RomPath="Test\/";
 			}
 			my $RomFile=$LinkAs;
 			if ($$ref{File}) {
@@ -625,7 +626,7 @@ my $ResrcIsSys;
 			elsif ($FixedProcess) {
 				$RomDecorations.='fixed';
 			}
-			my $IbyTextFrom="$RomFileType=$E32env::Data{RelPath}$Plat{Real}\\##BUILD##\\$Trg";
+			my $IbyTextFrom="$RomFileType=$e32env::Data{RelPath}$Plat{Real}\/##BUILD##\/$Trg";
 			my $IbyTextTo="$RomPath$RomFile";
 			my $Spaces= 60>length($IbyTextFrom) ? 60-length($IbyTextFrom) : 1; 
 #			&Output("\t\@echo \"", $IbyTextFrom, ' 'x$Spaces, "$IbyTextTo $RomDecorations\"\n");
@@ -633,7 +634,7 @@ my $ResrcIsSys;
 		}
 		foreach $ref (@RamTargets) {
 			my $RomFileType='data';
-			my $RomPath="Img\\";
+			my $RomPath="Img\/";
 			if ($$ref{Path}) {
 				$RomPath=$$ref{Path};
 			}
@@ -642,14 +643,13 @@ my $ResrcIsSys;
 				$RomFile=$$ref{File};
 			}
 			my $RomDecorations='attrib=r';
-			my $IbyTextFrom="$RomFileType=$E32env::Data{RelPath}$Plat{Real}\\##BUILD##\\$Trg";
+			my $IbyTextFrom="$RomFileType=$e32env::Data{RelPath}$Plat{Real}\/##BUILD##\/$Trg";
 			my $IbyTextTo="$RomPath$RomFile";
 			my $Spaces= 60>length($IbyTextFrom) ? 60-length($IbyTextFrom) : 1; 
 #			&Output("\t\@echo \"", $IbyTextFrom, ' 'x$Spaces, "$IbyTextTo $RomDecorations\"\n");
 			&Output("\t\@echo ", $IbyTextFrom, ' 'x$Spaces, "$IbyTextTo $RomDecorations\n");
 		}
 	}
-
 #	end rombuild
 
 	&PMEndSrcList if defined &PMEndSrcList;
@@ -692,7 +692,7 @@ sub FatalError (@) {
 
 sub Usage () {
 
-		eval { &Load_ModuleL('MAKHELP'); };
+		eval { &Load_ModuleL('makhelp'); };
 		die $@ if $@; 
 		eval { &Help_Invocation; };
 		die $@ if $@;
@@ -751,10 +751,10 @@ sub ASSPLinkPath () {
 	if ($CurBld) {
 #regression hack
 		if ($Plat{OS} eq 'EPOC32') {
-			$Path.="UREL\\";
+			$Path.="urel\/";
 		}
 		else {
-			$Path.="UDEB\\";
+			$Path.="udeb\/";
 		}
 #regression hack end
 	}
@@ -811,7 +811,8 @@ sub BldList () {
 sub BldPath () {
 	my $Path=$Path{"Bld"};
 	if ($CurBld) {
-		$Path.="$CurBld\\";
+		$CurBld = lc $CurBld;
+		$Path.="$CurBld\/";
 	}
 	$Path;
 }
@@ -825,7 +826,7 @@ sub DataLinkAddress () {
 	$DataLinkAddress;
 }
 sub DataPath () {
-	$E32env::Data{DataPath};
+	$e32env::Data{DataPath};
 }
 sub DebugLibList () {
 	@DebugLibList;
@@ -851,16 +852,16 @@ sub DocList () {
 	sort @DocList;
 }
 sub EPOCPath () {
-	$E32env::Data{EPOCPath};
+	$e32env::Data{EPOCPath};
 }
 sub EPOCIncPath () {
-	$E32env::Data{EPOCIncPath};
+	$e32env::Data{EPOCIncPath};
 }
 sub EPOCRelPath () {
-	$E32env::Data{RelPath};
+	$e32env::Data{RelPath};
 }
 sub EPOCToolsPath () {
-	$E32env::Data{EPOCToolsPath};
+	$e32env::Data{EPOCToolsPath};
 }
 sub Exports () {
 	@{$TrgType{Exports}{$Plat{"DefFile"}}};
@@ -892,10 +893,10 @@ sub LibPath () {
 	if ($CurBld) {
 #regression hack
 		if ($Plat{OS} eq 'EPOC32') {
-			$Path.="UREL\\";
+			$Path.="urel\/";
 		}
 		else {
-			$Path.="UDEB\\";
+			$Path.="udeb\/";
 		}
 #regression hack end
 	}
@@ -910,15 +911,16 @@ sub LinkPath () {
 	if ($CurBld) {
 #regression hack
 		if ($Plat{OS} eq 'EPOC32') {
-			$Path.="UREL\\";
+			$Path.="urel\/";
 		}
 		else {
-			$Path.="UDEB\\";
+			$Path.="udeb\/";
 		}
 #regression hack end
 	}
 	$Path;
 }
+
 sub MacroList ($) {
 	if ($_[0]) {
 	return @{$BldMacros{$_[0]}};
@@ -950,7 +952,7 @@ sub ProcessPriority () {
 sub RelPath () {
 	my $Path=$Path{Rel};
 	if ($CurBld) {
-		$Path.="$CurBld\\";
+		$Path.= lc "$CurBld\/";
 	}
 	$Path;
 }
@@ -976,8 +978,7 @@ sub	SetStdIncPaths (@) {
 	@StdIncPaths=();
 	my $Path;
 	foreach $Path (@_) {
-		$Path=uc $Path;
-		$Path=~s-^(.*[^\\])$-$1\\-o;
+		$Path=~s-^(.*[^\/])$-$1\/-o;
 		push @StdIncPaths, $Path;	# only place drive letters may appear, up to modules to handle
 	}
 }
@@ -1004,7 +1005,7 @@ sub StatLibList () {
 sub StatLinkPath () {
 	my $Path=$Path{StatLink};
 	if ($CurBld) {
-		$Path.="$CurBld\\";
+		$Path.="$CurBld\/";
 	}
 	$Path;
 }
@@ -1043,4 +1044,3 @@ sub UserIncPaths () {
 sub SrcDbg () {
 	$SrcDbg;
 }
-
diff --git a/maksym.pl b/maksym.pl
index 223a270..36af4d0 100644
--- a/maksym.pl
+++ b/maksym.pl
@@ -253,7 +253,7 @@ sub help ()
   {
 	my $build;
 
-	&Load_ModuleL('E32TPVER');
+	&Load_ModuleL('e32tpver');
 	print "\nmaksym - Produce symbolic information given a ROM image (Build ",
 	  &E32tpver, ")\n";
 	&usage;
diff --git a/memtrace.pl b/memtrace.pl
index 2d8fcf0..292a7f6 100644
--- a/memtrace.pl
+++ b/memtrace.pl
@@ -226,7 +226,7 @@ sub help ()
 	{
 	my $build;
 	
-	&Load_ModuleL('E32TPVER');
+	&Load_ModuleL('e32tpver');
 	print "\nmemtrace - " .
 	  "Postprocess EPOC memory usage trace (Build ", &E32tpver, ")\n";
 	&usage;
diff --git a/mmp.pm b/mmp.pm
index 8067625..6014cc5 100644
--- a/mmp.pm
+++ b/mmp.pm
@@ -1,3 +1,5 @@
+#!/usr/bin/perl -w
+#
 # MMP.PM
 #
 # Copyright (c) 1997-1999 Symbian Ltd.  All rights reserved.
@@ -6,7 +8,7 @@
 
 # Processes an mmp file and sets up subroutines to return the data
 
-package Mmp;
+package mmp;
 
 require Exporter;
 @ISA=qw(Exporter);
@@ -24,7 +26,7 @@ require Exporter;
 	Mmp_CallDllEntryPoints
 	Mmp_CompatibleABIs
 	Mmp_DataLinkAddress
-	Mmp_DebugLibList 
+	Mmp_DebugLibList
 	Mmp_Def
 	Mmp_DocHash
 	Mmp_ExportUnfrozen
@@ -32,7 +34,7 @@ require Exporter;
 	Mmp_FixedProcess
 	Mmp_HeapSize
 	Mmp_LangList
-	Mmp_LibList 
+	Mmp_LibList
 	Mmp_LinkAs
 	Mmp_Macros
 	Mmp_MmpFlag
@@ -43,7 +45,7 @@ require Exporter;
 	Mmp_RomTargets
 	Mmp_SrcHash
 	Mmp_StackSize
-	Mmp_StatLibList 
+	Mmp_StatLibList
 	Mmp_SysIncPaths
 	Mmp_SysResrcHash
 	Mmp_Trg
@@ -54,10 +56,10 @@ require Exporter;
 );
 
 
-use Genutl;
-use Prepfile;
-use Pathutl;
-use Trgtype;
+use genutl;
+use prepfile;
+use pathutl;
+use trgtype;
 
 my %Mode;
 
@@ -91,7 +93,7 @@ my $ProcessPriority='';
 my %ResrcHash;
 my @RamTargets;
 my @RomTargets=({}); # include default
-my %SrcHash;    
+my %SrcHash;
 my $StackSize='';
 my @StatLibList;
 my @SysIncPaths;
@@ -119,9 +121,6 @@ sub Mmp_ProcessL ($$) {
 		&Prepfile_SetVerbose;
 	}
 
-#	set the file-processor to upper-case all the data
-	&Prepfile_SetUpperCase;
-
 #	preprocess the project description file
 	my @Mmp2D;
 	eval { &Prepfile_ProcessL(\@Mmp2D, $MMPFILE, @{$$Plat_ref{MmpMacros}}); };
@@ -150,13 +149,14 @@ sub Mmp_ProcessL ($$) {
 	my ($CurSrcPath, $MmpMacro, $Line);
 	$CurSrcPath=$MmpPath;
 
-#	include the .MMP file as a document
+#	include the .mmp file as a document
 	@{$DocHash{$MmpPath}}=(&Path_Split('File', $MMPFILE));
 	$CheckDoc{$MMPFILE}='zero - specified by default';
 
 # process the data structure
 	my $CurFile=$MMPFILE;
 	LINE: foreach $Line (@Mmp2D) {
+		$Line =~ s/\r$//; # strip trailing cr
 		my $LineNum=shift @$Line;
 		$_=shift @$Line;
 		if ($LineNum eq '#') {
@@ -165,7 +165,7 @@ sub Mmp_ProcessL ($$) {
 		}
 
 		if ($PlatTxtSwitch) {
-			if (/^END$/o) {
+			if (/^END$/oi) {
 				$PlatTxtSwitch=0;
 				next LINE;
 			}
@@ -173,24 +173,24 @@ sub Mmp_ProcessL ($$) {
 			next LINE;
 		}
 		if ($OtherPlatSwitch) {
-			if (/^END$/o) {
+			if (/^END$/oi) {
 				$OtherPlatSwitch=0;
 				next LINE;
 			}
 			next LINE;
 		}
 		if (%CurBitMap) {
-			if (/^SOURCE$/o) {
+			if (/^SOURCE$/oi) {
 				unless (@$Line>1) {
 					push @MmpDie, "$CurFile($LineNum) : Not enough arguments for Bitmap keyword SOURCE\n";
 				}
 				my $ClDepth=shift @$Line;
-				unless ($ClDepth=~/^C?\d\d?$/o) {
+				unless ($ClDepth=~/^C?\d\d?$/io) {
 					push @MmpDie, "$CurFile($LineNum) : BITMAP color depth \"$ClDepth\" - unexpected format\n";
 				}
 				$ClDepth=lc $ClDepth; # bmconv can't handle upper-case 'C's
 				foreach (@$Line) {
-					$_=lc $_;	# bmconv generates a header with case-sensitive enums
+ 					$_=~s/\\/\//g;      # force to forward slash
 					push @{$CurBitMap{Source}}, { # sources must be kept in order
 						Src=>"$CurBitMapSrcPath$_",
 						ClDepth=>$ClDepth
@@ -201,26 +201,27 @@ sub Mmp_ProcessL ($$) {
 				}
 				next LINE;
 			}
-			if (/^END$/o) {
+			if (/^END$/oi) {
 				$CurBitMapSrcPath=$MmpPath;
 				my %BitMap=%CurBitMap;
 				undef %CurBitMap;
 				push @BitMapStruct, \%BitMap;
 				next LINE;
 			}
-			if (/^SOURCEPATH$/o) {
+			if (/^SOURCEPATH$/oi) {
 				unless ($CurBitMapSrcPath=shift @$Line) {
 					push @MmpDie, "$CurFile($LineNum) : No path specified with Bitmap keyword SOURCEPATH\n";
 					next LINE;
 				}
-				$CurBitMapSrcPath=~s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-				$CurBitMapSrcPath=&Path_MakeAbs($MMPFILE,$CurBitMapSrcPath);
+				$CurBitMapSrcPath=~s/\\/\//g;      # force to forward slash
+				$CurBitMapSrcPath=~s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a backslash
+				$CurBitMapSrcPath=&Path_MakeAbs($CurFile,$CurBitMapSrcPath);
 				if (@$Line) {
 					push @MmpWarn, "$CurFile($LineNum) : Too many arguments for Bitmap keyword SOURCEPATH\n";
 				}
 				next LINE;
 			}
-			if (/^HEADER$/o) {
+			if (/^HEADER$/oi) {
 				if ($CurBitMap{Hdr}) {
 					push @MmpWarn, "$CurFile($LineNum) : Bitmap HEADER already specified at line $CurBitMap{Hdr}\n";
 					next LINE;
@@ -231,7 +232,7 @@ sub Mmp_ProcessL ($$) {
 				}
 				next LINE;
 			}
-			if (/^TARGETPATH$/o) {
+			if (/^TARGETPATH$/oi) {
 				if ($CurBitMap{TrgPath}) {
 					push @MmpWarn, "$CurFile($LineNum) : Bitmap TARGETPATH already specified\n";
 					next LINE;
@@ -240,9 +241,10 @@ sub Mmp_ProcessL ($$) {
 					push @MmpDie, "$CurFile($LineNum) : No path specified with Bitmap keyword TARGETPATH\n";
 					next LINE;
 				}
-				$CurBitMap{TrgPath}=~s-^\\(.*)$-$1-o;
-				$CurBitMap{TrgPath}=~s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-				$CurBitMap{TrgPath}="Z\\$CurBitMap{TrgPath}";
+				$CurBitMap{TrgPath}=~s/\\/\//g;              # force to forward slash
+				$CurBitMap{TrgPath}=~s-^\/(.*)$-$1-o;
+				$CurBitMap{TrgPath}=~s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a slash
+				$CurBitMap{TrgPath}="z\/$CurBitMap{TrgPath}";
 				if (@$Line) {
 					push @MmpWarn, "$CurFile($LineNum) : Too many arguments for Bitmap keyword TARGETPATH\n";
 				}
@@ -250,7 +252,7 @@ sub Mmp_ProcessL ($$) {
 			}
 			push @MmpWarn, "$CurFile($LineNum) : Unrecognised Bitmap Keyword \"$_\"\n";
 		}
-		if (/^START$/) {
+		if (/^START$/i) {
 			unless ($_=shift @$Line) {
 				push @MmpWarn, "$CurFile($LineNum) : No Argument specified for START block\n";
 				next LINE;
@@ -261,11 +263,12 @@ sub Mmp_ProcessL ($$) {
 					next LINE;
 				}
 			}
-			if ($_ eq 'BITMAP') {
+			if (uc $_ eq 'BITMAP') {
 				unless ($CurBitMap{Trg}=shift @$Line) {
 					push @MmpWarn, "$CurFile($LineNum) : No Bitmap Target specified\n";
 					$CurBitMap{Trg}='NoTargetSpecified';
 				}
+				$CurBitMap{Trg}=~s/\\/\//g;      # force to forward slash
 				if (@$Line) {
 					push @MmpWarn, "$CurFile($LineNum) : Too many arguments for START BITMAP clause\n";
 				}
@@ -275,23 +278,26 @@ sub Mmp_ProcessL ($$) {
 			next LINE;
 		}
 
-		if (/^AIF$/o) {
+		if (/^AIF$/oi) {
 			my %Data;
 			($Data{Trg}, $Data{Dir}, $Data{Resrc}, $Data{ClDepth}, @{$Data{BitMaps}})=@$Line;
 			unless ($Data{Resrc}) { # bitmaps aren't essential
 				push @MmpDie, "$CurFile($LineNum) : Not enough arguments for keyword AIF\n";
 				next LINE;
 			}
-			$Data{Dir}=~s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-			$Data{Dir}=&Path_MakeAbs($MMPFILE, $Data{Dir});
+			$Data{Trg}=~s/\\/\//g;      # force to forward slash
+			$Data{Dir}=~s/\\/\//g;      # force to forward slash
+			$Data{Dir}=~s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a slash
+			$Data{Dir}=&Path_MakeAbs($CurFile, $Data{Dir});
 			my $File;
 			foreach $File ($Data{Resrc}, @{$Data{BitMaps}}) {
+				$File=~s/\\/\//g;      # force to forward slash
 				unless (-e "$Data{Dir}$File") {
 					push @MmpWarn, "$CurFile($LineNum) : AIF source \"$Data{Dir}$File\" not found\n";
 				}
 			}
 			if ($Data{ClDepth}) {
-				unless ($Data{ClDepth}=~/^C?\d\d?$/o) {
+				unless ($Data{ClDepth}=~/^C?\d\d?$/io) {
 					push @MmpDie, "$CurFile($LineNum) : AIF color depth \"$Data{ClDepth}\" - unexpected format\n";
 				}
 				$Data{ClDepth}=lc $Data{ClDepth}; # bmconv can't handle upper-case 'C's
@@ -304,21 +310,21 @@ sub Mmp_ProcessL ($$) {
 			push @AifStruct, \%Data;
 			next LINE;
 		}
-		if (/^ASSPABI$/o) {
+		if (/^ASSPABI$/oi) {
 			if (@$Line) {
 				push @MmpWarn, "$CurFile($LineNum) : Keyword $_ takes no arguments\n";
 			}
 			$ASSPABISwitch=1;
 			next LINE;
 		}
-		if (/^ASSPEXPORTS$/o) {
+		if (/^ASSPEXPORTS$/oi) {
 			if (@$Line) {
 				push @MmpWarn, "$CurFile($LineNum) : Keyword $_ takes no arguments\n";
 			}
 			$ASSPExports=1;
 			next LINE;
 		}
-		if (/^ASSPLIBRARY$/o) {
+		if (/^ASSPLIBRARY$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
@@ -334,7 +340,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Libraries specified for keyword ASSPLIBRARY\n";
 			next LINE;
 		}
-		if (/^DEBUGLIBRARY$/o) {
+		if (/^DEBUGLIBRARY$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
@@ -350,7 +356,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Libraries specified for keyword DEBUGLIBRARY\n";
 			next LINE;
 		}
-		if (/^DEFFILE$/o)  {
+		if (/^DEFFILE$/oi)  {
 			if ($CheckDef) {
 				push @MmpWarn, "$CurFile($LineNum) : Attempt to redefine DEFFILE\n";
 				next LINE;
@@ -360,18 +366,20 @@ sub Mmp_ProcessL ($$) {
 				push @MmpWarn, "$CurFile($LineNum) : No file specified for keyword DEFFILE\n";
 				next LINE;
 			}
+			$_=~s/\\/\//g;      # force to forward slash
 			$Def{Base}=&Path_Split('Base',$_);
 			$Def{Ext}=&Path_Split('Ext',$_);
 			$Def{Path}=&Path_Split('Path',$_);
 			if ($Def{Path}) {
-				$Def{Path}=&Path_MakeEAbs($EPOCPath,$MMPFILE,$Def{Path});
+				$Def{Path}=&Path_MakeEAbs($EPOCPath,$CurFile,$Def{Path});
 			}
 			next LINE;
 		}
-		if (/^DOCUMENT$/o) {
+		if (/^DOCUMENT$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
+ 					$Candidate=~s/\\/\//g;      # force to forward slash
 					if ($CheckDoc{"$CurSrcPath$Candidate"}) {
 						push @MmpWarn, "$CurFile($LineNum) : Duplicate Document \"$CurSrcPath$Candidate\" at line ", $CheckDoc{"$CurSrcPath$Candidate"}, "\n";
 						next; 
@@ -387,21 +395,21 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Files specified for keyword DOCUMENT\n";
 			next LINE;
 		}
-		if (/^EPOCALLOWDLLDATA$/o) {
+		if (/^EPOCALLOWDLLDATA$/oi) {
 			if (@$Line) {
 				push @MmpWarn, "$CurFile($LineNum) : Keyword $_ takes no arguments\n";
 			}
 			$AllowDllData=1;
 			next LINE;
 		}
-		if (/^EPOCCALLDLLENTRYPOINTS$/o) {
+		if (/^EPOCCALLDLLENTRYPOINTS$/oi) {
 			if (@$Line) {
 				push @MmpWarn, "$CurFile($LineNum) : Keyword $_ takes no arguments\n";
 			}
 			$CallDllEntryPoints=1;
 			next LINE;
 		}
-		if (/^EPOCDATALINKADDRESS$/o) {
+		if (/^EPOCDATALINKADDRESS$/oi) {
 			if (@$Line) { 
 				my $temp=&main::Genutl_AnyToHex(shift @$Line);
 				if (defined $temp) {
@@ -413,14 +421,14 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No data link address specified for keyword $_\n";
 			next LINE;
 		}
-		if (/^EPOCFIXEDPROCESS$/o) {
+		if (/^EPOCFIXEDPROCESS$/oi) {
 			if (@$Line) {
 				push @MmpWarn, "$CurFile($LineNum) : Keyword $_ takes no arguments\n";
 			}
 			$FixedProcess=1;
 			next LINE;
 		}
-		if (/^EPOCHEAPSIZE$/o) {
+		if (/^EPOCHEAPSIZE$/oi) {
 			if (@$Line) {
 				my $tempMin=&main::Genutl_AnyToHex(shift @$Line);
 				if (defined $tempMin) {
@@ -443,7 +451,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No minimum heap size specified for keyword $_\n";
 			next LINE;
 		}
-		if (/^EPOCPROCESSPRIORITY$/o) {
+		if (/^EPOCPROCESSPRIORITY$/oi) {
 			if ($ProcessPriority) {
 				push @MmpWarn, "$CurFile($LineNum) : Attempt to redefine EPOCPROCESSPRIORITY\n";
 				next LINE;
@@ -458,7 +466,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Priority specified for keyword EPOCPROCESSPRIORITY\n";
 			next LINE;
 		}
-		if (/^EPOCSTACKSIZE$/o) {
+		if (/^EPOCSTACKSIZE$/oi) {
 			if (@$Line) {
 				my $temp=&main::Genutl_AnyToHex(shift @$Line);
 				if (defined $temp) {
@@ -471,14 +479,14 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No stack size specified for keyword STACKSIZE\n";
 			next LINE;
 		}
-		if (/^EXPORTUNFROZEN$/o) {
+		if (/^EXPORTUNFROZEN$/oi) {
 			if (@$Line) {
 				push @MmpWarn, "$CurFile($LineNum) : Keyword $_ takes no arguments\n";
 			}
 			$ExportUnfrozen=1;
 			next LINE;
 		}
-		if (/^FIRSTLIB$/o) {
+		if (/^FIRSTLIB$/oi) {
 			if ($FirstLib) {
 				push @MmpWarn, "$CurFile($LineNum) : Attempt to redefine FIRSTLIB\n";
 				next LINE;
@@ -489,7 +497,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : Nothing specified for keyword FIRSTLIB\n";
 			next LINE;
 		}
-		if (/^LANG$/o) {
+		if (/^LANG$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
@@ -497,7 +505,7 @@ sub Mmp_ProcessL ($$) {
 						push @MmpWarn, "$CurFile($LineNum) : Duplicate Language \"$Candidate\" at line $CheckLang{$Candidate}\n";
 						next; 
 					}
-					push @LangList, $Candidate;
+					push @LangList, lc $Candidate;
 					$CheckLang{$Candidate}="$CurFile($LineNum)";
 				}
 				next LINE;
@@ -505,7 +513,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Languages specified for keyword LANG\n";
 			next LINE;
 		}
-		if (/^LIBRARY$/o) {
+		if (/^LIBRARY$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
@@ -522,7 +530,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Libraries specified for keyword LIBRARY\n";
 			next LINE;
 		}
-		if (/^LINKAS$/o) {
+		if (/^LINKAS$/oi) {
 			if ($LinkAs) {
 				push @MmpWarn, "$CurFile($LineNum) : Attempt to redefine LINKAS\n";
 				next LINE;
@@ -533,13 +541,13 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No name specified for keyword LINKAS\n";
 			next LINE;
 		}
-		if (/^MACRO$/o) {
+		if (/^MACRO$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
 					if ($CheckMacro{$Candidate}) {
 						push @MmpWarn, "$CurFile($LineNum) : Duplicate Macro \"$Candidate\" at line $CheckMacro{$Candidate}\n";
-						next; 
+						next;
 					}
 					push @Macros, $Candidate;
 					$CheckMacro{$Candidate}="$CurFile($LineNum)";
@@ -549,7 +557,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Macros specified for keyword MACRO\n";
 			next LINE; 
 		}
-		if (/^NOSTRICTDEF$/o) {
+		if (/^NOSTRICTDEF$/oi) {
 			if ($NoStrictDef) {
 				push @MmpWarn, "$CurFile($LineNum) : NOSTRICTDEF already set\n";
 				next LINE;
@@ -560,7 +568,7 @@ sub Mmp_ProcessL ($$) {
 			$NoStrictDef=1;
 			next LINE;
 		}
-		if (/^RAMTARGET$/o) {
+		if (/^RAMTARGET$/oi) {
 			if ($CheckRamTargets) {
 				push @MmpWarn, "$CurFile($LineNum) : RAM targets already specified at line $CheckRamTargets\n";
 				next LINE;
@@ -584,10 +592,11 @@ sub Mmp_ProcessL ($$) {
 			}
 			next LINE;
 		}
-		if (/^RESOURCE$/o) {
+		if (/^RESOURCE$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
+ 					$Candidate=~s/\\/\//g;      # force to forward slash
 					if ($CheckResrc{$Candidate}) {
 						push @MmpDie, "$CurFile($LineNum) : Duplicate Resource $Candidate at line $CheckResrc{$Candidate}\n";
 						next;
@@ -600,7 +609,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Resources specified for keyword RESOURCE\n";
 			next LINE; 
 		}
-		if (/^ROMTARGET$/o) {
+		if (/^ROMTARGET$/oi) {
 			if ($CheckRomTargets) {
 				push @MmpWarn, "$CurFile($LineNum) : ROM targets already specified at line $CheckRomTargets\n";
 				next LINE;
@@ -625,10 +634,11 @@ sub Mmp_ProcessL ($$) {
 			}
 			next LINE;
 		}
-		if (/^SOURCE$/o) {
+		if (/^SOURCE$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
+ 					$Candidate=~s/\\/\//g;      # force to forward slash
 					if ($CheckSrc{$Candidate}) {
 						push @MmpDie, "$CurFile($LineNum) : Duplicate Source \"$Candidate\" at line $CheckSrc{$Candidate}\n";
 						next;
@@ -641,9 +651,10 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Sources specified for keyword SOURCE\n";
 			next LINE; 
 		}
-		if (/^SOURCEPATH$/o) {
+		if (/^SOURCEPATH$/oi) {
 			if ($CurSrcPath=shift @$Line) {
-				$CurSrcPath=~s-^(.*[^\\])$-$1\\-o;	# in case no terminating backslash
+ 				$CurSrcPath=~s/\\/\//g;      # force to forward slash
+				$CurSrcPath=~s-^(.*[^\/])$-$1\/-o;	# in case no terminating slash
 				$CurSrcPath=&Path_MakeAbs($MMPFILE,$CurSrcPath);
 				if (-d &Path_Chop($CurSrcPath)) {
 					next LINE;
@@ -654,7 +665,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpDie, "$CurFile($LineNum) : No Source Path specified for keyword SOURCEPATH\n";
 			next LINE;
 		}
-		if (/^STATICLIBRARY$/o) {
+		if (/^STATICLIBRARY$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
@@ -670,7 +681,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Libraries specified for keyword STATICLIBRARY\n";
 			next LINE;
 		}
-		if (/^STRICTDEPEND$/o) {
+		if (/^STRICTDEPEND$/oi) {
 			if ($MmpFlag{StrictDepend}) {
 				push @MmpWarn, "$CurFile($LineNum) : STRICTDEPEND already set\n";
 				next LINE;
@@ -681,12 +692,13 @@ sub Mmp_ProcessL ($$) {
 			$MmpFlag{StrictDepend}=1;
 			next LINE;
 		}
-		if (/^SYSTEMINCLUDE$/o){
+		if (/^SYSTEMINCLUDE$/oi){
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
-					$Candidate=~s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-					$Candidate=&Path_MakeEAbs($EPOCPath,$MMPFILE,$Candidate);
+ 					$Candidate=~s/\\/\//g;      # force to forward slash
+ 					$Candidate=~s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a slash
+					$Candidate=&Path_MakeEAbs($EPOCPath,$CurFile,$Candidate);
 					if ($CheckSysInc{$Candidate}) {
 						push @MmpWarn, "$CurFile($LineNum) : Duplicate SYSTEMINCLUDE path $Candidate at line $CheckSysInc{$Candidate}\n";
 						next; 
@@ -703,7 +715,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Paths specified for keyword SYSTEMINCLUDE\n";
 			next LINE;
 		}
-		if (/^SYSTEMRESOURCE$/o) {
+		if (/^SYSTEMRESOURCE$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
@@ -719,7 +731,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Resources specified for keyword SYSTEMRESOURCE\n";
 			next LINE; 
 		}
-		if (/^TARGET$/o) {
+		if (/^TARGET$/oi) {
 			if ($Trg) {
 				push @MmpWarn, "$CurFile($LineNum) : Attempt to redefine TARGET\n";
 				next LINE;
@@ -730,7 +742,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Target specified for keyword TARGET\n";
 			next LINE;
 		}
-		if (/^TARGETPATH$/o) {
+		if (/^TARGETPATH$/oi) {
 			if ($TrgPath) {
 				push @MmpWarn, "$CurFile($LineNum) : Attempt to redefine TARGETPATH\n";
 				next LINE;
@@ -739,15 +751,16 @@ sub Mmp_ProcessL ($$) {
 				push @MmpWarn, "$CurFile($LineNum) : No Path specified for keyword TARGETPATH\n";
 				next LINE;
 			}
-			$TrgPath=~s-^\\(.*)$-$1-o;
-			$TrgPath=~s-^(.*[^\\])$-$1\\-o;
-			$TrgPath="Z\\$TrgPath";
+			$TrgPath=~s/\\/\//g;              # force to forward slash
+			$TrgPath=~s-^\/(.*)$-$1-o;
+			$TrgPath=~s-^(.*[^\/])$-$1\/-o;
+			$TrgPath="z\/$TrgPath";
 			if (@$Line) {
 				push @MmpWarn, "$CurFile($LineNum) : Too many arguments for keyword TARGETPATH\n";
 			}
 			next LINE;
 		}
-		if (/^TARGETTYPE$/o) {
+		if (/^TARGETTYPE$/oi) {
 			if ($TrgType) {
 				push @MmpWarn, "$CurFile($LineNum) : Attempt to redefine TARGETTYPE\n";
 				next LINE;
@@ -762,7 +775,7 @@ sub Mmp_ProcessL ($$) {
 			}
 			next LINE;
 		}
-		if (/^UID$/o) {
+		if (/^UID$/oi) {
 			if (@$Line) {
 				foreach (@$Line) {
 					if ($#UidList>=1) {
@@ -782,12 +795,13 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Uids specified for keyword UID\n";
 			next LINE;
 		}
-		if (/^USERINCLUDE$/o) {
+		if (/^USERINCLUDE$/oi) {
 			if (@$Line) {
 				my $Candidate;
 				foreach $Candidate (@$Line) {
-					$Candidate=~s-^(.*[^\\])$-$1\\-o;   # ensure path ends with a backslash
-					$Candidate=&Path_MakeEAbs($EPOCPath,$MMPFILE,$Candidate);
+ 					$Candidate=~s/\\/\//g;      # force to forward slash
+					$Candidate=~s-^(.*[^\/])$-$1\/-o;   # ensure path ends with a slash
+					$Candidate=&Path_MakeEAbs($EPOCPath,$CurFile,$Candidate);
 					if ($CheckUserInc{$Candidate}) {
 						push @MmpWarn, "$CurFile($LineNum) : Duplicate USERINCLUDE path \"$Candidate\" at line $CheckUserInc{$Candidate}\n";
 						next; 
@@ -804,7 +818,7 @@ sub Mmp_ProcessL ($$) {
 			push @MmpWarn, "$CurFile($LineNum) : No Paths specified for keyword USERINCLUDE\n";
 			next LINE;
 		}
-		if (/^SRCDBG$/o) {
+		if (/^SRCDBG$/oi) {
 			if (@$Line) {
 				push @MmpWarn, "$CurFile($LineNum) : Keyword $_ takes no arguments\n";
 			}
@@ -875,7 +889,7 @@ sub Mmp_ProcessL ($$) {
 #	PUT IN SOME DEFAULTS
 
 	# check for languages
-	@LangList=('SC') unless @LangList;
+	@LangList=('sc') unless @LangList;
 
 #	COMPLETE THE UID LIST
 
@@ -940,7 +954,7 @@ sub Mmp_ProcessL ($$) {
 #	Get the EPOC entrypoint static library - must be done after EXEDLL basic types reconciled
 	unless ($FirstLib) {
 		unless ($TrgType{FirstLib}) {
-			$FirstLib="E$TrgType{Basic}.LIB";
+			$FirstLib= lc "E$TrgType{Basic}.lib";
 		}
 		else {
 			$FirstLib=$TrgType{FirstLib};
@@ -1002,21 +1016,21 @@ sub Mmp_ProcessL ($$) {
 			$Def{Base}=&Path_Split('Base',$LinkAs);
 		}
 		unless ($Def{Ext}) {
-			$Def{Ext}='.DEF';
+			$Def{Ext}='.def';
 		}
 		unless ($Def{Path}) {
 			unless ($ASSPExports) {
-				$Def{Path}=&Path_Strip(&Path_Split('Path',$MMPFILE)."..\\B$$Plat_ref{DefFile}\\");
+				$Def{Path}=&Path_Strip(&Path_Split('Path',$MMPFILE)."..\/b".lc $$Plat_ref{DefFile}."\/");
 			}
 			else {
-				$Def{Path}=&Path_Strip(&Path_Split('Path',$MMPFILE)."..\\B$$Plat_ref{ASSP}\\");
+				$Def{Path}=&Path_Strip(&Path_Split('Path',$MMPFILE)."..\/b".lc $$Plat_ref{ASSP}."\/");
 			}
 		}
 #		now that we've dumped narrow, treat the 'U' basename suffix as part of the frozen
 #		.DEF file basename.  Once we've dumped the suffix we won't have to store the extension
 #		separately either
 		unless ($NoStrictDef) {
-			$Def{Base}.='U';
+			$Def{Base}.='u';
 		}
 
 #		check deffile exists
@@ -1128,7 +1142,7 @@ sub Mmp_TrgType () {
 sub Mmp_UidList () {
 	@UidList;
 }
-sub	Mmp_UserIncPaths () {
+sub Mmp_UserIncPaths () {
 	@UserIncPaths;
 }
 sub Mmp_SrcDbg () {
diff --git a/modload.pm b/modload.pm
index bb08510..38bde43 100644
--- a/modload.pm
+++ b/modload.pm
@@ -7,7 +7,7 @@
 # Runtime module-loading routine for loading e32tools modules into 'main' module
 
 
-package Modload;
+package modload;
 
 require Exporter;
 @ISA=qw(Exporter);
@@ -19,7 +19,7 @@ require Exporter;
 );
 
 
-use Pathutl;
+use pathutl;
 
 my %Mode=(
 	Verbose=>0
@@ -40,14 +40,14 @@ sub Load_ModuleL (@) {
 	my @ModBaseList=@_;
 	my $ModBase;
 	foreach $ModBase (@ModBaseList) {
-		$ModBase=uc $ModBase;
-		die "ERROR: Can't load \"$ModulePath$ModBase.PM\"\n" unless -e "$ModulePath$ModBase.PM";
+		$ModBase=lc $ModBase;
+		die "ERROR: Can't load \"$ModulePath$ModBase.pm\"\n" unless -e "$ModulePath$ModBase.pm";
 		if ($Mode{Verbose}) {
-			print "Loading Module: \"",$ModBase,".PM\"\n";
+			print "Loading Module: \"",$ModBase,".pm\"\n";
 		}
 		package main;
-		require $ModBase.".PM" or die "ERROR: Can't load function from \"$ModulePath$ModBase.PM\"\n";
-		my $Package=ucfirst lc $ModBase;
+		require $ModBase.".pm" or die "ERROR: Can't load function from \"$ModulePath$ModBase.pm\"\n";
+		my $Package=$ModBase;
 		$Package->import;
 	}
 }
diff --git a/output.pm b/output.pm
index afd6c8e..0335e0b 100644
--- a/output.pm
+++ b/output.pm
@@ -6,7 +6,7 @@
 
 # Text formatting module
 
-package Output;
+package output;
 require Exporter;
 @ISA=qw(Exporter);
 @EXPORT=qw(
@@ -15,7 +15,6 @@ require Exporter;
 );
 
 
-
 my $Len=80;
 my $PreWrap="\\";
 my $PreWrapLen=length($PreWrap);
@@ -86,9 +85,8 @@ sub OutWrite () {
 
 sub Output (@) {
 	OutWrite if $Buf;	# output the formatted text before doing any more output
-	my $Item;
-	foreach $Item (@_) {
-		$Text.=$Item;
+	foreach (@_) {
+	  $Text .= $_ if $_;
 	}
 }
 
diff --git a/pathutl.pm b/pathutl.pm
index b62616b..f79a9c0 100644
--- a/pathutl.pm
+++ b/pathutl.pm
@@ -1,6 +1,6 @@
 # PATHUTL.PM
 #
-# Copyright (c) 1997-1999 Symbian Ltd.  All rights reserved.
+# Copyright (c) 1997-2001 Symbian Ltd.  All rights reserved.
 #
 
 
@@ -9,7 +9,7 @@
 #	Distinguish paths from filepaths by assuming paths end with "\"
 #	therefore ensure this is the case for all paths coming into programs using this module
 
-package Pathutl;
+package pathutl;
 
 require Exporter;
 @ISA=qw(Exporter);
@@ -31,11 +31,10 @@ my $WorkPath;
 
 BEGIN {
 # get the current working directory
-	$WorkPath=uc cwd;
-	$WorkPath=~s-/-\\-go; # separator from Perl 5.005_02+ is forward slash
+	$WorkPath=cwd;
 	$WorkPath=~s/^(.:)(\S+)$/$2/o;    # remove drive letter
 	$Drive=$1;
-	$WorkPath=~s-^(.*[^\\])$-$1\\-o;        # ensure workpath ends with a backslash
+	$WorkPath=~s-^(.*[^\/])$-$1\/-o;        # ensure workpath ends with a slash
 }
 
 sub Path_SetVerbose () {
@@ -86,27 +85,26 @@ sub Path_DelFiles (@) {
 sub Path_Split ($$) {	#args: $_[0] 'Path' or 'Base' or 'Ext' $_[1] Abs/Rel FilePath/Path
 # return the section of a file path required - Path, Base, Ext or File
 	my ($Sect,$P)=@_;
-	$Sect=ucfirst lc $Sect;
 	if ($Sect eq 'Path') {
-		if ($P=~/^(.*\\)/o) {
+		if ($P=~/^(.*\/)/o) {
 			return $1;
 		}
 		return '';
 	}
 	if ($Sect eq 'Base') {
-		if ($P=~/\\?([^\\]*?)(\.[^\\\.]*)?$/o) {
+		if ($P=~/\/?([^\/]*?)(\.[^\/\.]*)?$/o) {
 			return $1;
 		}
 		return '';
 	}
 	if ($Sect eq 'Ext') {
-		if ($P=~/(\.[^\\\.]*)$/o) {
+		if ($P=~/(\.[^\/\.]*)$/o) {
 			return $1;
 		}
 		return '';
 	}
 	if ($Sect eq 'File') {
-		if ($P=~/([^\\]*)$/o) {
+		if ($P=~/([^\/]*)$/o) {
 			return $1;
 		}
 		return '';
@@ -116,25 +114,25 @@ sub Path_Split ($$) {	#args: $_[0] 'Path' or 'Base' or 'Ext' $_[1] Abs/Rel FileP
 
 sub Path_Dirs ($) {	#args: $_[0] Abs FilePath/Path
 # return an ordered list of individual directories that make up a path
-	return undef unless $_[0]=~m-^\\-o;
+	return undef unless $_[0]=~m-^\/-o;
 	my $P=&Path_Split('Path',$_[0]);
-	return undef unless $P=~s-^(.*)\\$-$1-o;
-	$P=~s-^\\(.*)-$1-o;
-	split /\\/,$P;
+	return undef unless $P=~s-^(.*)\/$-$1-o;
+	$P=~s-^\/(.*)-$1-o;
+	split /\//,$P;
 }
 
 sub Path_StepDirs ($) { #args: $_[0] Abs FilePath/Path
 # return an ordered list of paths - starting with the directory in the root directory from the
 # path passed into the function, each subsequent path contains the next directory from the path
 # passed into the function, and the last path is the same as the path passed into the function
-	return undef unless $_[0]=~m-^\\-o;
+	return undef unless $_[0]=~m-^\/-o;
 	my $P=$_[0];
 	my @Dirs=&Path_Dirs($P);
 	my @StepDirs;
 	my $dir;
-	my $stepDir="\\";
+	my $stepDir="\/";
 	foreach $dir (@Dirs) {
-		$stepDir.="$dir\\";
+		$stepDir.="$dir\/";
 		push @StepDirs, $stepDir;
 	}
 	@StepDirs;
@@ -142,10 +140,10 @@ sub Path_StepDirs ($) { #args: $_[0] Abs FilePath/Path
 
 sub Path_Strip ($) {	#args: $_[0] Abs FilePath/Path
 # Remove excess occurrences of '..' and '.' from a path
-	return undef unless $_[0]=~m-^\\-o;
+	return undef unless $_[0]=~m-^\/-o;
 	my $P=$_[0];
-	while ($P=~s-\\\.\\-\\-go) { }
-	while ($P=~s-\\(?!\.{2}\\)[^\\]*\\\.{2}(?=\\)--go) { }
+	while ($P=~s-\/\.\/-\/-go) { }
+	while ($P=~s-\/(?!\.{2}\/)[^\/]*\/\.{2}(?=\/)--go) { }
 	$P;
 }
 
@@ -154,10 +152,10 @@ sub Path_MakePathL (@) {	#args: @_ list of Abs FilePath/Path
 	my @Paths=@_;
 	my $P;
 	foreach $P (@Paths) { 
-		return undef unless $P=~m-^\\-o;
+		return undef unless $P=~m-^\/-o;
 		$P=&Path_Split('Path',$P);
 		$P=&Path_Strip($P);
-		$P=~m-(.*)\\-o;
+		$P=~m-(.*)\/-o;
 		if (-d $1) {
 			if ($Mode{'Verbose'}) {
 				print "Existing Path: \"$P\"\n";
@@ -167,9 +165,9 @@ sub Path_MakePathL (@) {	#args: @_ list of Abs FilePath/Path
 		my @StepDirs=&Path_StepDirs($P);
 		my $dir;
 		STEP: foreach $dir (@StepDirs) {
-			$dir=~s-\\$--o;	# -d can't handle trailing backslash, neither can mkdir
+			$dir=~s-\/$--o;	# -d can't handle trailing backslash, neither can mkdir
 			next STEP if -d $dir;
-			mkdir "$dir",2 or die "ERROR: Can't make step directory \"$dir\"\n";
+			mkdir "$dir", 0775 or die "ERROR: Can't make step directory \"$dir\"\n";
 		}
 		if ($Mode{'Verbose'}) {
 			print "Created Path: \"$P\"\n";
@@ -181,24 +179,24 @@ sub Path_MakePathL (@) {	#args: @_ list of Abs FilePath/Path
 sub Path_UpToRoot ($) {	#args: $_[0] Abs FilePath/Path
 # return the path that will lead from the directory the path passed into the function
 # specifies back up to the root directory
-	return undef unless $_[0]=~m-^\\-o;
+	return undef unless $_[0]=~m-^\/-o;
 	my $Path=$_[0];
 	my @List=&Path_Dirs($Path);
 	undef $Path;
 	my $UpP='';
-	foreach (@List) { $UpP.="..\\"; }
+	foreach (@List) { $UpP.="..\/"; }
 	$UpP;
 }
 
 sub Path_MakeRlt ($@) {	#args: $_[0] Start UpPath $_[1]... list of (Abs FilePath/Path)
 # make a path, or list of paths, relative to a particular directory specified by the first
 # path passed into the function which leads upwards from a particular directory
-	return undef unless $_[0]=~m-(|\\$)-o;	# allow for null value passed in
+	return undef unless $_[0]=~m-(|\/$)-o;	# allow for null value passed in
 	my ($UpPath,@List)=@_;
 	my $p;
 	foreach $p (@List) {
-		return undef unless $p=~m-^\\-o;
-		$p=~s-^\\(.*)$-$1-o;
+		return undef unless $p=~m-^\/-o;
+		$p=~s-^\/(.*)$-$1-o;
 		$p=$UpPath.$p;
 	}
 	return wantarray ? @List : $List[0];	
@@ -208,7 +206,7 @@ sub Path_MakeAbs ($@) {	#args: $_[0] Start Abs FilePath/Path $_[1]... list of (A
 # make a path, or list of paths, absolute given the directory specified by the first path
 # passed into the function which the other paths passed into the function are assumed to be
 # relative to
-	return undef unless $_[0]=~m-^\\-o;
+	return undef unless $_[0]=~m-^\/-o;
 	my ($Path,@List)=@_;
 	my $BasePath=&Path_Split("Path",$Path);
 	undef $Path;
@@ -218,14 +216,14 @@ sub Path_MakeAbs ($@) {	#args: $_[0] Start Abs FilePath/Path $_[1]... list of (A
 			$p=&Path_Strip($BasePath.$p);
 			next;
 		}
-		if ($p=~m-^[^\.\\]-o) {
+		if ($p=~m-^[^\.\/]-o) {
 			$p=$BasePath.$p;
 			next;
 		}
-		if ($p=~m-^\\-o) {
+		if ($p=~m-^\/-o) {
 			next;
 		}
-		if ($p=~m-^\.\\(.*)$-o) {
+		if ($p=~m-^\.\/(.*)$-o) {
 			$p=&Path_Strip($BasePath.$1);
 			next;
 		}
@@ -235,20 +233,20 @@ sub Path_MakeAbs ($@) {	#args: $_[0] Start Abs FilePath/Path $_[1]... list of (A
 }
 
 sub Path_MakeEAbs ($@) {	#args: $_[0] Start EPOCPath Abs FilePath/Path $_[1]... list of (Abs/Rel FilePath/Path)
-# Variant of MakAbs which also maps "+\\" to "${EPOCPath}"
-	return undef unless $_[0]=~m-^\\-o;
+# Variant of MakAbs which also maps "+\/" to "${EPOCPath}"
+	return undef unless $_[0]=~m-^\/-o;
 	my ($EPOCPath,$Path,@List)=@_;
 	my $BasePath=&Path_Split("Path",$Path);
 	undef $Path;
 	my $p;
 	foreach $p (@List) {
 #regression hack
-		if ($p=~m-^\\epoc32\\(.*)$-io) {	# hack - special case for existing \\epoc32 references
+		if ($p=~m-^\/epoc32\/(.*)$-io) {	# hack - special case for existing \/epoc32 references
 			$p=$EPOCPath.$1;
 			next;
 		}
 #regression hack end
-		if ($p=~m-\+\\(.*)$-o) {
+		if ($p=~m-\+\/(.*)$-o) {
 			$p=$EPOCPath.$1;
 			next;
 		}
@@ -256,14 +254,14 @@ sub Path_MakeEAbs ($@) {	#args: $_[0] Start EPOCPath Abs FilePath/Path $_[1]...
 			$p=&Path_Strip($BasePath.$p);
 			next;
 		}
-		if ($p=~m-^[^\.\\]-o) {
+		if ($p=~m-^[^\.\/]-o) {
 			$p=$BasePath.$p;
 			next;
 		}
-		if ($p=~m-^\\-o) {
+		if ($p=~m-^\/-o) {
 			next;
 		}
-		if ($p=~m-^\.\\(.*)$-o) {
+		if ($p=~m-^\.\/(.*)$-o) {
 			$p=&Path_Strip($BasePath.$1);
 			next;
 		}
@@ -273,11 +271,11 @@ sub Path_MakeEAbs ($@) {	#args: $_[0] Start EPOCPath Abs FilePath/Path $_[1]...
 }
 
 sub Path_Chop (@) {
-# remove the terminating backslash from a path, or list of paths, if there is one
+# remove the terminating slash from a path, or list of paths, if there is one
 	my @List=@_;
 	my $Path;
 	foreach $Path (@List) {
-		$Path=~s-^(.*)\\$-$1-o;
+		$Path=~s-^(.*)\/$-$1-o;
 	}
 	return wantarray ? @List : $List[0];
 }
diff --git a/perllib/args.pm b/perllib/args.pm
index 91170e7..ebeaaf5 100644
--- a/perllib/args.pm
+++ b/perllib/args.pm
@@ -684,7 +684,7 @@ sub AddArgsSpec($$$$$$)
 		}
 
     # add the given ArgSpec to the SpecArray under the name of the argument
-    $self->_iSpecArray->{$aName}= New CArgsSpec($aName, $aDefault, $aPattern, $aExclusions, $aMandatory, $aRepeatable);
+    $self->_iSpecArray->{$aName}= CArgsSpec->New($aName, $aDefault, $aPattern, $aExclusions, $aMandatory, $aRepeatable);
     }
 
 ################################################################################
diff --git a/perllib/devtools.pm b/perllib/devtools.pm
index fda81f8..7cf086b 100644
--- a/perllib/devtools.pm
+++ b/perllib/devtools.pm
@@ -251,7 +251,7 @@ sub ExtractFileName($)
 	{
 	my($fileName)=@_;
 
-	$fileName =~ s/.*[\\:]([^\\:]*$)/$1/;
+	$fileName =~ s/.*[\/:]([^\/:]*$)/$1/;
 
 	return $fileName;
 	}
@@ -309,7 +309,7 @@ sub ExtractPath($)
 	{
 	my($path)=@_;
 
-	$path =~ /(.*[\\:])[^\\:]*$/;
+	$path =~ /(.*[\/:])[^\/:]*$/;
 	$path=$1;
 
 	return $path;
diff --git a/perllib/params.pm b/perllib/params.pm
index 9299063..ffa326d 100644
--- a/perllib/params.pm
+++ b/perllib/params.pm
@@ -50,7 +50,7 @@ sub New
     bless $self, $class;
 
     # create a log object for this object
-    $self->_iLog(New CLog());
+    $self->_iLog(CLog->New());
 
     $self->_iParamsArray({});
     
@@ -110,7 +110,7 @@ sub AddParamItem($$$)
     if(!$self->Exists($aName))
 		{
 		# it has not been added create the ParamsEntry
-		my $paramsEntry = New CParamsEntry();
+		my $paramsEntry = CParamsEntry->New();
 		$self->_iParamsArray->{$aName} = $paramsEntry;
 		}
 
@@ -159,7 +159,7 @@ sub _ParamsEntry($)
     my $self = shift;
     my($aName) = @_;
 
-    my $result = New CParamsEntry();
+    my $result = CParamsEntry->New();
 
     #check that this parameter Entry exists
     if($self->Exists($aName))
@@ -191,7 +191,7 @@ sub ParamItem($$)
     my($aName, $aIndex) = @_;
 
     # make a new paramItem to use if there is not one in existance
-    my $result = New CParamItem(undef,undef,undef,New CParamsEntry());
+    my $result = CParamItem->New(undef,undef,undef,CParamsEntry->New());
     my $index = 0;
 
     # if an index is given take the Param Item with this index
@@ -389,7 +389,7 @@ sub New()
     bless $self, $class;
 
     # create a log object for this object
-    $self->_iLog(New CLog());
+    $self->_iLog(CLog->New());
 
     $self->_iParamItems([]);
     $self->_iDefaultParamItem(undef);
@@ -457,12 +457,12 @@ sub AddParamItem
     # check if the parameter item is the default
     if($aDefault)
 		{
-		$self->_iDefaultParamItem(New CParamItem($aName,$aValue,$aDefault,$self));
+		$self->_iDefaultParamItem(CParamItem->New($aName,$aValue,$aDefault,$self));
 		}
     else
 		{
 		#add the paramItem
-		push(@{$self->_iParamItems},New CParamItem($aName,$aValue,$aDefault,$self));
+		push(@{$self->_iParamItems},CParamItem->New($aName,$aValue,$aDefault,$self));
 		}
     }
 
@@ -716,7 +716,7 @@ sub New($$$$)
     bless $self, $class;
 
     # create a log object for this object
-    $self->_iLog(New CLog());
+    $self->_iLog(CLog->New());
 
     $self->_iName($aName);
     $self->_iValue($aValue);
@@ -1020,13 +1020,13 @@ sub TEST
     # argument spec to the array
     $self->_iLog->Log("Test 1 create a paramItem");
 
-    my $obj1 = New CParamItem("TestPara1", "Default value", 1, undef);
+    my $obj1 = CParamItem->New("TestPara1", "Default value", 1, undef);
 
     $self->_iLog->Log("Print the default value for this ParamItem (should be Default value)");
     $self->_iLog->Log("Default vlaue is ".$obj1->DefaultValue());
 
     $self->_iLog->Log("Test 2 create a non default paramitem");
-    $obj1 = New CParamItem("TestPara1", "Value", 0, undef);
+    $obj1 = CParamItem->New("TestPara1", "Value", 0, undef);
 
     $self->_iLog->Log("Print the default value for this ParamItem (should be undef)");
     $self->_iLog->Log("Default value is ".$obj1->DefaultValue());
diff --git a/perllib/xml/dom.pm b/perllib/xml/dom.pm
index de0b52d..d10f40c 100644
--- a/perllib/xml/dom.pm
+++ b/perllib/xml/dom.pm
@@ -50,7 +50,7 @@ use vars qw( $VERSION @ISA @EXPORT
 	     %DefaultEntities %DecodeDefaultEntity
 	   );
 use Carp;
-use XML::RegExp;
+use xml::regexp;
 
 BEGIN
 {
@@ -191,9 +191,16 @@ sub encodeText
     my ($str, $default) = @_;
     return undef unless defined $str;
     
-    $str =~ s/([\xC0-\xDF].|[\xE0-\xEF]..|[\xF0-\xFF]...)|([$default])|(]]>)/
-	defined($1) ? XmlUtf8Decode ($1) : 
-	defined ($2) ? $DecodeDefaultEntity{$2} : "]]&gt;" /egs;
+    if ($] >= 5.006) {
+      $str =~ s/([$default])|(]]>)/
+        defined ($1) ? $DecodeDefaultEntity{$1} : "]]&gt;" /egs;
+      $str =~ s/([^\x00-\x7F])/'&#' . ord($1) . ';'/gse;
+    }
+    else {
+      $str =~ s/([\xC0-\xDF].|[\xE0-\xEF]..|[\xF0-\xFF]...)|([$default])|(]]>)/
+        defined($1) ? XmlUtf8Decode ($1) :
+        defined ($2) ? $DecodeDefaultEntity{$2} : "]]&gt;" /egs;
+    }
 
 #?? could there be references that should not be expanded?
 # e.g. should not replace &#nn; &#xAF; and &abc;
diff --git a/petran b/petran
new file mode 100644
index 0000000..bf9fdfa
--- /dev/null
+++ b/petran
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# petran - bash frontend for petran.exe, part of GnuPoc project
+#
+# (c) 2001 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+PGM=`basename $0`
+echo "executing $PGM.exe"
+ROOT=$EPOCROOT/epoc32/tools
+wine $ROOT/$PGM.exe "$@"
diff --git a/pfsdump b/pfsdump
new file mode 100644
index 0000000..283311c
--- /dev/null
+++ b/pfsdump
@@ -0,0 +1,17 @@
+#!/bin/sh
+#
+# pfsdump - bash frontend for pfsdump.exe, part of GnuPoc project
+#
+# PFS = Permanent File Store
+#
+# (c) 2001 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+PGM=`basename $0`
+echo "executing $PGM.exe"
+ROOT=$EPOCROOT/epoc32/tools
+wine $ROOT/$PGM.exe "$@"
diff --git a/prepfile.pm b/prepfile.pm
index a4a3f01..738fea7 100644
--- a/prepfile.pm
+++ b/prepfile.pm
@@ -7,7 +7,7 @@
 # module for preprocessing makmake-style project files
 
 
-package Prepfile;
+package prepfile;
 
 require Exporter;
 @ISA=qw(Exporter);
@@ -17,8 +17,8 @@ require Exporter;
 );
 
 
-use Checkgcc;
-use Pathutl;
+use checkgcc;
+use pathutl;
 
 my %Mode=(
 	Verbose=>0,
@@ -42,7 +42,7 @@ sub Prepfile_ProcessL ($$@) {
 	die "\nERROR: Project File \"$FILE\" not found\n" unless -e $FILE;
 
 	my @CppCall;
-	push @CppCall, 'CPP.EXE -undef';
+	push @CppCall, 'arm-epoc-pe-cpp';
 
 	my $Macro;
 	# add CL macros to the CPP call for preprocessing of the file
@@ -52,12 +52,15 @@ sub Prepfile_ProcessL ($$@) {
 	}
 	# all macros made upper case and suppress user-expansion of macros for nefarious purposes
 
-	push @CppCall, join '',"\"",&Path_RltToWork($FILE),"\"";
+	# common sense
+	push @CppCall, "-D __SERIES60__=__SERIES60__";
+
+	push @CppCall, join '',"\"",$FILE,"\"";
 	if ($Mode{'Verbose'}) {
 		print "@CppCall\n";
 	}
 	my $CPPPIPE;
-	open CPPPIPE,"@CppCall |" or die "ERROR: Can't invoke CPP.EXE\n";
+	open CPPPIPE,"@CppCall |" or die "ERROR: Can't invoke CPP\n";
 	undef @CppCall;
 
 
@@ -76,14 +79,14 @@ sub Prepfile_ProcessL ($$@) {
 
 		my @Tmp=();
 
-	    # Process the file information lines that cpp inserts.
+		# Process the file information lines that cpp inserts.
 		# (note that we don't currently do anything with the
 		# number cpp sometimes puts out after the filename -
 		# it's something to do with inclusion nesting levels)
 		if (/^# (\d+) "(.*)"( \d+)?/o) {
 			$LineNum = scalar $1;
 			my $CurFile=$2;
-			$CurFile=~s-\\\\-\\-go;
+			$CurFile=~s-\\\\-\\-go; # TODO
 			$CurFile=&Path_MakeAbs($FILE, $CurFile);
 			@Tmp=('#', $CurFile);
 			push @{$ArrayRef}, [ @Tmp ];
@@ -115,7 +118,7 @@ sub Prepfile_ProcessL ($$@) {
 		}
 	}
 
-	close CPPPIPE or die "ERROR: CPP.EXE Failure\n";
+	close CPPPIPE or die "ERROR: CPP Failure\n";
 }
 
 1;
diff --git a/rcomp b/rcomp
new file mode 100644
index 0000000..345a4ce
--- /dev/null
+++ b/rcomp
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# rcomp - bash frontend for rcomp.exe, part of GnuPoc project
+#
+# (c) 2001 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+PGM=`basename $0`
+echo "executing $PGM.exe"
+ROOT=$EPOCROOT/epoc32/tools
+wine $ROOT/$PGM.exe "$@"
diff --git a/rtf2ptml b/rtf2ptml
new file mode 100644
index 0000000..fa2b4bf
--- /dev/null
+++ b/rtf2ptml
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# rtf2ptml - bash frontend for rtf2ptml.exe, part of GnuPoc project
+#
+# (c) 2001 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+PGM=`basename $0`
+echo "executing $PGM.exe"
+ROOT=$EPOCROOT/epoc32/tools
+wine $ROOT/$PGM.exe "$@"
diff --git a/setupcomms b/setupcomms
new file mode 100644
index 0000000..7e0d917
--- /dev/null
+++ b/setupcomms
@@ -0,0 +1,12 @@
+#!/bin/sh
+#
+# setupcomms - bash interface for setupcomms.pl, part of GnuPoc project
+#
+# (c) 2002 Alfred E. Heggestad
+#
+#    This program is free software; you can redistribute it and/or modify
+#    it under the terms of the GNU General Public License version 2 as
+#    published by the Free Software Foundation.
+#
+
+perl -S setupcomms.pl "$@"
diff --git a/setupcomms.pl b/setupcomms.pl
index b2011e6..2d88d73 100644
--- a/setupcomms.pl
+++ b/setupcomms.pl
@@ -1,3 +1,4 @@
+#!/usr/bin/perl -w
 #
 # Setupcomms Launcher
 #
@@ -43,8 +44,8 @@ sub launchT_commsDb
     my $type = shift;
     $epocroot = &getEpocroot;
     $drive = &getDrive;
-    $emu = $drive . $epocroot . "epoc32" . "\\" 
-	. "release\\wins\\" . $type . "\\" . "T_editdb.exe";
+    $emu = $drive . $epocroot . "/epoc32" . "/" 
+	. "release/wins/" . $type . "/" . "t_editdb.exe";
     -e $emu ||
 	die "ERROR: File \"$emu\" not found.\n\n" .
 	    "The EPOCROOT environment variable does not identify\n" .
@@ -57,7 +58,7 @@ sub launchT_commsDb
 	$emu.=" -MConsole --";
 			
     # If the execute is successful, this never returns.
-    exec($emu) || die "Failed to execute setupcomms \"$emu\": $!";
+    exec("wine " . $emu) || die "Failed to execute setupcomms \"$emu\": $!";
 }
 
 sub printHelp
@@ -77,11 +78,10 @@ sub getEpocroot
     my $epocroot = $ENV{EPOCROOT};
     die "ERROR: Must set the EPOCROOT environment variable.\n"
 	if (!defined($epocroot));
-    $epocroot =~ s-/-\\-go;	# for those working with UNIX shells
     die "ERROR: EPOCROOT must be an absolute path, " .
-	"not containing a drive letter.\n" if ($epocroot !~ /^\\/);
+	"not containing a drive letter.\n" if ($epocroot !~ /^\//);
     die "ERROR: EPOCROOT must not be a UNC path.\n" if ($epocroot =~ /^\\\\/);
-    die "ERROR: EPOCROOT must end with a backslash.\n" if ($epocroot !~ /\\$/);
+    die "ERROR: EPOCROOT must end with a forward slash.\n" if ($epocroot !~ /\/$/);
     die "ERROR: EPOCROOT must specify an existing directory.\n" 
 	if (!-d $epocroot);
     return $epocroot;
diff --git a/trgtype.pm b/trgtype.pm
index 709eebb..19331eb 100644
--- a/trgtype.pm
+++ b/trgtype.pm
@@ -10,7 +10,7 @@
 # Look at the existing types for an appropriate example
 #
 
-package Trgtype;
+package trgtype;
 
 require Exporter;
 @ISA=qw(Exporter);
@@ -19,7 +19,7 @@ require Exporter;
 	Trg_List
 );
 
-use Genutl;
+use genutl;
 
 my %Types=(
 	ANI=>{
@@ -49,7 +49,7 @@ my %Types=(
 			MARM=>['NewComponentTestLC__FR11CDataLoggerR22MComponentTestObserver'],
 			WINS=>['?NewComponentTestLC@@YAPAVCComponentTester@@AAVCDataLogger@@AAVMComponentTestObserver@@@Z'],
 		},
-		Path=>'system\Apps\testbed\tests',
+		Path=>'system/apps/testbed/tests',
 		UID2=>'0x10009DF0',
 	},
 	DLL=>{
@@ -83,11 +83,11 @@ my %Types=(
 		UID2=>'0x100039df',
 	},
 	KDLL=>{
-		FirstLib=>'EDEV.LIB',
+		FirstLib=>'edev.lib',
 		Kernel=>1,
 	},
 	KEXT=>{
-		FirstLib=>'EEXT.LIB',
+		FirstLib=>'eext.lib',
 		Kernel=>1,
 	},
 	KLIB=>{
@@ -95,7 +95,7 @@ my %Types=(
 		Kernel=>1,
 	},
 	LDD=>{
-		FirstLib=>'EDEV.LIB',
+		FirstLib=>'edev.lib',
 		Kernel=>1,
 		'Exports'=>{
 			MARM=>['CreateLogicalDevice__Fv'],
@@ -111,7 +111,7 @@ my %Types=(
 			MARM=>['ImplementationGroupProxy__FRi'],
 			WINS=>['?ImplementationGroupProxy@@YAPBUTImplementationProxy@@AAH@Z'],
 		},
-		Path=>'System\Libs\Plugins',
+		Path=>'system/libs/plugins',
 		UID2=>'0x10009D8D',
 	},
 	MDA=>{
@@ -133,7 +133,7 @@ my %Types=(
 			MARM=>['NotifierArray__Fv'],
 			WINS=>['?NotifierArray@@YAPAV?$CArrayPtr@VMEikSrvNotifierBase@@@@XZ'],
 		},
-		Path=>'System\Notifiers',
+		Path=>'system/notifiers',
 		UID2=>'0x10005522',
 	},
 	OPX=>{
@@ -144,7 +144,7 @@ my %Types=(
 		UID2=>'0x10003a7b',
 	},
 	PDD=>{
-		FirstLib=>'EDEV.LIB',
+		FirstLib=>'edev.lib',
 		Kernel=>1,
 		'Exports'=>{
 			MARM=>['CreatePhysicalDevice__Fv'],
@@ -170,7 +170,7 @@ my %Types=(
 		'Exports'=>{
 			MARM=>['VariantInitialise__Fv'],
 		},
-		FirstLib=>'EVAR.LIB',
+		FirstLib=>'evar.lib',
 		Kernel=>1,
 	},
 	WLOG=>{
@@ -250,7 +250,7 @@ sub Trg_GetL ($$$) {
 		# apply terminating backslash
 		$TrgHash{Path}=~s-^(.*[^\\])$-$1\\-o;
 		# apply Z drive
-		$TrgHash{Path}="Z\\$TrgHash{Path}";
+		$TrgHash{Path}="z/$TrgHash{Path}";
 	}
 
 	unless ($TrgHash{UID2}) {
diff --git a/winutl.pm b/winutl.pm
index 5f04377..1dc6f2b 100644
--- a/winutl.pm
+++ b/winutl.pm
@@ -6,7 +6,7 @@
 
 # this package does various ancillary things for windows modules
 
-package Winutl;
+package winutl;
 
 my $BaseAddress='';
 my @Win32LibList=();
@@ -41,7 +41,7 @@ sub Winutl_DoMmp (@) { # takes platform text
 
 
 #	check that we're using VC5 SP3
-	open PIPE, "LINK.EXE |" or die "ERROR: Can't invoke LINK.EXE\n";
+	open PIPE, "wine LINK.EXE |" or die "ERROR: Can't invoke LINK.EXE\n";
 	my $DoneCheck=0;
 	while (<PIPE>) {
 		unless ($DoneCheck) {
@@ -118,7 +118,7 @@ sub Winutl_DoMmp (@) { # takes platform text
 		my $UidText=join(
 			"\n",
 			'// Makmake-generated uid source file',
-			'#include <E32STD.H>',
+			'#include <e32std.h>',
 			'#pragma data_seg(".E32_UID")',
 			'__WINS_UID('
 		);
@@ -130,7 +130,7 @@ sub Winutl_DoMmp (@) { # takes platform text
 		$UidText.="#pragma data_seg()\n";
 # tools hack
 		unless (&main::Plat eq 'TOOLS') {
-			&main::AddSrc("$MakeFilePath$BaseTrg.UID.CPP", $UidText);
+			&main::AddSrc("$MakeFilePath$BaseTrg.uid.cpp", $UidText);
 		};
 # tools hack end
 	}
